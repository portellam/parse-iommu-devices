#!/bin/bash

#
# Filename:       parse-iommu-devices
# Description:    Bash script to parse, sort, and display hardware devices by
#                 selected IOMMU group, and return the device drivers and
#                 hardware IDs as output.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
# Version:        1.0.2
#

#
# TODO:
# - [ ] add validation for all inputs.
# - [ ] fix output to show every IOMMU group and it's device info.
# - [ ] fix lists?
#

shopt -s nullglob

declare -r SCRIPT_VERSION="1.0.2"
declare -r SCRIPT_NAME="$( basename "${0}" )"
declare -i MIN_VGA_INDEX_VALUE=1
declare -i MIN_IOMMU_VALUE=0

declare -A ARGUMENTS=(
  ["GET_MINIMUM_OUTPUT"]=false
  ["GROUPS_TO_MATCH"]=""
  ["GROUPS_TO_REVERSE_MATCH"]=""
  ["MATCH_GROUPS"]=false
  ["MATCH_HOST"]=false
  ["MATCH_NAMES"]=false
  ["MATCH_PCI"]=false
  ["MATCH_VGA_GROUP_INDEX"]=false
  ["NAMES_TO_MATCH"]=""
  ["NAMES_TO_REVERSE_MATCH"]=""
  ["REVERSE_MATCH_GROUPS"]=false
  ["REVERSE_MATCH_NAMES"]=false
  ["VGA_GROUP_INDEX_TO_MATCH"]=""
)

declare -A OUTPUTS=(
  ["FOUND_GROUP_ID_LIST"]=""
  ["FOUND_HOST_GROUP_ID_LIST"]=""
  ["FOUND_PCI_GROUP_ID_LIST"]=""
  ["FOUND_VGA_GROUP_ID_LIST"]=""
  ["SELECTED_DRIVERS"]=""
  ["SELECTED_GROUP_ID_LIST"]=""
  ["SELECTED_HARDWARE_ID_LIST"]=""
  ["UNSELECTED_GROUP_ID_LIST"]=""
)

function wrap_text
{
  column  --separator '|' \
          --table \
          --output-width 30 \
          --table-noheadings \
          --table-columns C1,C2 \
          --table-wrap C2 \
    key1|$1
}

function append_output_to_lists
{
  # if ! is_quiet_enabled \
  #   && ! is_output_empty; then

  if "${has_host}"; then
    OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]+="${group_id},"
  fi

  if "${has_pci}"; then
    OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]+="${group_id},"
  fi

  if "${has_vga}"; then
    OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]+="${group_id},"
    (( vga_group_index++ ))
  fi

  if ! "${is_selected}"; then
    OUTPUTS["UNSELECTED_GROUP_ID_LIST"]+="${group_id},"
    return 0
  fi

  OUTPUTS["SELECTED_DRIVERS"]+="${driver_list}"
  OUTPUTS["SELECTED_GROUP_ID_LIST"]+="${group_id},"
  OUTPUTS["SELECTED_HARDWARE_ID_LIST"]+="${hardware_id_list}"
}

function append_output_to_temp_lists
{
  if ! is_quiet_enabled; then
    local driver_output="\t\tDriver:\t\t"

    if [[ ! -z "${driver}" ]]; then
      driver_output+="${driver}"
    else
      driver_output+="N/A"
    fi

    name_output="$( echo "${name}" | fmt --crown-margin )"

    group_output+=(
      "\t${device_index}.\tSlot ID:\t${bus_id}"
      "\t\tName:\t\t${name_output}"
      "\t\tHardware ID:\t${hardware_id}"
      "${driver_output}"
    )

    group_output+=( "" )
  fi

  if [[ ",${group_id_list,,}," != *",${group_id},"* ]]; then
    group_id_list+="${group_id},"
  fi

  if [[ ",${driver_list,,}," != *",${driver},"* ]]; then
    driver_list+="${driver},"
  fi

  if [[ ",${hardware_id_list,,}," != *",${hardware_id},"* ]]; then
    hardware_id_list+="${hardware_id},"
  fi
}

function convert_found_group_id_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["FOUND_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["FOUND_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["FOUND_GROUP_ID_LIST"]="${OUTPUTS["FOUND_GROUP_ID_LIST"]::-1}"

  OUTPUTS["FOUND_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["FOUND_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_found_host_group_id_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]::-1}"

  OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_found_pci_group_id_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]="${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]::-1}"

  OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_found_vga_group_id_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]::-1}"

  OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_selected_driver_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["SELECTED_DRIVERS"]}" ]]; then
    OUTPUTS["SELECTED_DRIVERS"]="N/A"
    return 0
  fi

  OUTPUTS["SELECTED_DRIVERS"]="${OUTPUTS["SELECTED_DRIVERS"]::-1}"

  OUTPUTS["SELECTED_DRIVERS"]="$( \
    echo "${OUTPUTS["SELECTED_DRIVERS"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_selected_group_id_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["SELECTED_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["SELECTED_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["SELECTED_GROUP_ID_LIST"]="${OUTPUTS["SELECTED_GROUP_ID_LIST"]::-1}"

  OUTPUTS["SELECTED_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["SELECTED_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_selected_hardware_id_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}" ]]; then
    OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]::-1}"

  OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="$( \
    echo "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_unselected_group_id_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]::-1}"

  OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function is_comma_delimited_list_of_positive_numbers
{
  if echo "${1}" \
      | grep --extended-regexp --quiet '^(?!\d+(,\d+)*$)([^,]+(,[^,]+)*)?$'; then
    echo -e "Error: Input is not a comma delimited list of positive numbers."
    return 1
  fi
}

function is_output_empty
{
  if [[ "${#group_output[@]}" -lt 1 ]]; then
    return 1
  fi
}

function is_quiet_enabled
{
  if ! "${ARGUMENTS["GET_MINIMUM_OUTPUT"]}"; then
    return 1
  fi

  return 0
}

function parse_arguments
{
  if [[ "${1}" == "-"* ]] \
    && [[ "${1}" != "--"* ]]; then
    for char in $( \
      echo "${1:1}" \
        | sed -e 's/\(.\)/\1\n/g'
    ); do
      argument="-${char}"

      if [[ -z "${argument}" ]]; then
        break
      fi

      parse_argument "${argument}"
    done

    shift
  fi

  parse_argument "${@}"
}

function parse_argument
{
  while [[ ! -z "${1}" ]]; do
    case "${1,,}" in
      "-g" | "--groups" )
        ARGUMENTS["MATCH_GROUPS"]=true
        shift

        if ! is_comma_delimited_list_of_positive_numbers "${1}" \
          || [[ "${1}" -lt "${MIN_IOMMU_VALUE}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["GROUPS_TO_MATCH"]="${1}"
        ;;

      "-H" | "--host" )
        ARGUMENTS["MATCH_HOST"]=true
        ;;

      "--ignore-group" )
        ARGUMENTS["REVERSE_MATCH_GROUPS"]=""
        shift

        if ! is_comma_delimited_list_of_positive_numbers "${1}" \
          || [[ "${1}" -lt "${MIN_IOMMU_VALUE}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]="${1}"
        ;;

      "--ignore-name" )
        ARGUMENTS["REVERSE_MATCH_NAMES"]=true
        shift

        if [[ -z "${1}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["NAMES_TO_REVERSE_MATCH"]="${1}"
        ;;

      "-p" | "--pci" | "--pcie" )
        ARGUMENTS["MATCH_PCI"]=true
        ;;

      "-q" | "--quiet" )
        ARGUMENTS["GET_MINIMUM_OUTPUT"]=true
        ;;

      "-v" | "--vga-index" )
        ARGUMENTS["MATCH_VGA_GROUP_INDEX"]=true
        shift

        if ! is_comma_delimited_list_of_positive_numbers "${1}" \
          || [[ "${1}" -lt "${MIN_VGA_INDEX_VALUE}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["VGA_GROUP_INDEX_TO_MATCH"]="${1}"
        ;;

    "-n" | "--name" )
        ARGUMENTS["MATCH_NAMES"]=true
        shift

        if [[ -z "${1}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["NAMES_TO_MATCH"]="${1}"
        ;;

      "" )
        return 0
        ;;

      "-h" | "--help" )
        print_usage
        exit 2
        ;;

      * )
        print_invalid_argument
        ;;

    esac

    shift
  done
}

function parse_group_devices
{
  set_device_properties
  set_group_properties
  set_name_match_property
  set_reverse_name_match_property
  set_vga_type_match_property

  if "${ARGUMENTS["MATCH_HOST"]}" \
      && ! "${has_host}" \
      && ! "${ARGUMENTS["MATCH_PCI"]}"; then
    return 1
  fi

  if "${ARGUMENTS["MATCH_PCI"]}" \
      && ! "${has_pci}" \
      && ! "${ARGUMENTS["MATCH_HOST"]}"; then
    return 1
  fi

  if "${ARGUMENTS["MATCH_NAMES"]}" \
      && ! "${has_name}" \
      && ! "${ARGUMENTS["REVERSE_MATCH_NAMES"]}"; then
    return 1
  fi

  if "${ARGUMENTS["REVERSE_MATCH_NAMES"]}" \
      && ! "${has_reverse_name}" \
      && ! "${ARGUMENTS["MATCH_NAMES"]}"; then
    return 1
  fi

  if "${ARGUMENTS["MATCH_VGA_GROUP_INDEX"]}" \
      && ! "${has_vga}"; then
    return 1
  fi

  is_selected=true
  append_output_to_temp_lists
}

function parse_group
{
  group_id="${group##*/}"
  OUTPUTS["FOUND_GROUP_ID_LIST"]+="${group_id},"

  if ! is_quiet_enabled; then
    group_output+=(
      "IOMMU Group ${group_id}:"
    )
  fi

  # if "${ARGUMENTS["MATCH_GROUPS"]}" \
  #   && ! echo ",${ARGUMENTS["GROUPS_TO_MATCH"]}," \
  #     | grep --quiet ",${group_id},"; then
  #   return 1
  # fi

  # if "${ARGUMENTS["REVERSE_MATCH_GROUPS"]}" \
  #   && ! echo ",${ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]}," \
  #     | grep --quiet ",${group_id},"; then
  #   return 1
  # fi

  if "${ARGUMENTS["MATCH_GROUPS"]}" \
    && [[ ! -z "${ARGUMENTS["GROUPS_TO_MATCH"]}" ]] \
    && echo "${ARGUMENTS["GROUPS_TO_MATCH"]}" \
        | grep --quiet "${group_id}"; then
    return 1
  fi

  if "${ARGUMENTS["REVERSE_MATCH_GROUPS"]}" \
    && ! [[ -z "${ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]}" ]] \
    && echo "${ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]}" \
        | grep --quiet "${group_id}"; then
    return 1
  fi

  device_index=0
  group_id_list=""
  driver_list=""
  hardware_id_list=""
  has_host=false
  has_pci=false
  has_name=false
  has_reverse_name=false
  has_vga=false
  is_selected=false

  for device in ${group##}/devices/*; do
    parse_group_devices
  done

  append_output_to_lists
}

function parse_groups
{
  local -i vga_group_index=0

  for group in $( \
    find /sys/kernel/iommu_groups/* -maxdepth 0 -type d \
      | sort --version-sort
  ); do
    parse_group
  done

  verify_vga_group_index "${vga_group_index}"
  convert_found_group_id_list_to_delimited_string
  convert_found_host_group_id_list_to_delimited_string
  convert_found_pci_group_id_list_to_delimited_string
  convert_found_vga_group_id_list_to_delimited_string
  convert_selected_driver_list_to_delimited_string
  convert_selected_group_id_list_to_delimited_string
  convert_selected_hardware_id_list_to_delimited_string
  convert_unselected_group_id_list_to_delimited_string
}

function print_invalid_option
{
  is_quiet_enabled && exit 1
  echo -e "Error: Invalid option specified."
  exit 1
}

function print_invalid_argument
{
  echo -e "Error: Invalid option specified."
  echo -e "Error: Invalid argument(s) specified."
  print_usage
  exit 1
}

function print_output
{
  if is_quiet_enabled; then
    if is_output_empty; then
      return 1
    else
      echo "${OUTPUTS["SELECTED_DRIVERS"]}"
      echo "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}"
      return 0
    fi
  fi

  # if is_output_empty; then
  #   echo -e "Error: No IOMMU groups found."
  #   return 1
  # fi

  # TODO: just output groups here.
  # TODO: make a function to format output given iommu id, not like devices will change immediately.

  for line in "${group_output[@]}"; do
    echo -e "${line}"
  done

  echo -e "Groups:\n${OUTPUTS["FOUND_GROUP_ID_LIST"]}"
  echo
  echo -e "Groups with Host device(s):\n${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}"
  echo
  echo -e "Groups with PCI device(s):\n${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]}"
  echo
  echo -e "Groups with VGA device(s):\n${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}"
  echo
  echo -e "Unselected Groups:\n${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}"
  echo
  echo -e "Selected Groups:\n${OUTPUTS["SELECTED_GROUP_ID_LIST"]}"
  echo
  echo -e "Selected Drivers:\n${OUTPUTS["SELECTED_DRIVERS"]}"
  echo
  echo -e "Selected Hardware IDs:\n${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}"
}

function print_with_fold
{
  echo -e "${*}" | fold
}

function print_usage
{
  if is_quiet_enabled; then
    return 0
  fi

  text="$( \
    wrap_text \
      "Quiet all output except for comma delimited lists of device drivers and" \
      "hardware IDs." \
  )"

  echo -e "Usage:\t${SCRIPT_NAME} [ARGUMENTS]"
  echo
  echo -e "Parse, sort, and display hardware devices by IOMMU group(s)."
  echo -e "Version ${SCRIPT_VERSION}."
  echo
  echo -e "  -h, --help                Print this help and exit."

  echo -e "  -q, --quiet               ${text}"

  echo -e "  -g, --group=GROUPS        Match IOMMU group ID(s);"

  echo -e "                            GROUPS is a comma delimited list of" \
    "numbers."

  echo -e "  --ignore-group=GROUPS     Reverse match IOMMU group ID(s);"

  echo -e "                            GROUPS is a comma delimited list of" \
    "numbers."

  echo -e "  -H, --host                Match IOMMU groups with at least one" \
    "(1) or more Host devices."

  echo -e "  --ignore-name=NAME        Match IOMMU group(s) without device" \
    "name;"

  echo -e "                            NAME is a comma delimited list of" \
    "text."

  echo -e "  -n, --name=NAME           Match IOMMU group(s) with device" \
    "name;"

  echo -e "                            NAME is a comma delimited list of" \
    "text."

  echo -e "  -p, --pci, --pcie         Match IOMMU groups with at least one" \
    "(1) or more PCI and/or PCIe bus devices."

  echo -e "  -v, --vga-index=INDEX     Match all IOMMU groups without VGA," \
    "and any with VGA which match the index value(s) (not an IOMMU group ID);"

  echo -e "                            INDEX is a comma delimited list of" \
    "numbers."

  echo
  echo -e "Examples:"

  echo -e "  ${SCRIPT_NAME} --ignore-name ether --pcie -q -v 2"

  echo -e "                            Quiet output except for drivers and" \
  "hardware IDs (of IOMMU groups with PCI/e devices), exclude IOMMU" \
  "groups with VGA device(s) before and after the second matched group, and" \
  "exclude any wired ethernet devices (onboard or PCI/e)."
}

function set_device_properties
{
  (( device_index++ ))
  name="$( lspci -s ${device##*/} )"
  name="${name:8}"

  bus_id="$( \
    lspci -ns ${device##*/} \
      | awk 'END {print $1}'
  )"

  hardware_id="$( \
    lspci -ns ${device##*/} \
      | awk 'END {print $3}'
  )"

  driver="$( \
    lspci -kns ${device##*/} \
      | grep "driver" \
      | awk 'END {print $5}'
  )"
}

function set_group_properties
{
  internal_bus_id="00"
  this_bus_id="${bus_id::2}"

  if [[ "${this_bus_id}" == "${internal_bus_id}" ]]; then
    has_host=true
  else
    has_pci=true
  fi
}

function set_name_match_property
{
  if "${has_name}" \
    || ! "${ARGUMENTS["MATCH_NAMES"]}"; then
    return 0
  fi

  for this_name in $( \
    echo "${ARGUMENTS["NAMES_TO_MATCH"]}" \
      | sed "s/,/ /g"
  ); do
    if echo "${name,,}" \
        | grep --invert-match --quiet "${this_name,,}"; then
      continue
    fi

    has_name=true
  done
}

function set_reverse_name_match_property
{
  if "${has_reverse_name}" \
    || ! "${ARGUMENTS["REVERSE_MATCH_NAMES"]}"; then
    return 0
  fi

  for this_name in $( \
    echo "${ARGUMENTS["NAMES_TO_REVERSE_MATCH"]}" \
    | sed "s/,/ /g" \
  ); do
    if echo "${name,,}" \
        | grep --quiet "${this_name,,}"; then
      continue
    fi

    has_reverse_name=true
  done
}

function set_vga_type_match_property
{
  if echo "${name,,}" \
      | grep --quiet "vga"; then
    has_vga=true
  fi
}

function verify_groups
{
  local -i greatest_iommu="$( \
    ls /sys/kernel/iommu_groups/ \
      | sort --reverse --version-sort \
      | head --lines 1
  )"

  if ! is_comma_delimited_list_of_positive_numbers \
      "${ARGUMENTS["GROUPS_TO_MATCH"]}" \
    || [[ "$( echo "${ARGUMENTS["GROUPS_TO_MATCH"]}" \
      | sort --reverse --version-sort \
      | --lines 1)" -gt "${greatest_iommu}" ]]; then
    echo -e "Error: Invalid IOMMU group ID(s) specified."

    echo "Please enter a number between '${MIN_IOMMU_VALUE}' and '${greatest_iommu}'."

    exit 1
  fi

  if ! is_comma_delimited_list_of_positive_numbers \
      "${ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]}" \
    || [[ "$( echo "${ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]}" \
      | sort --reverse --version-sort \
      | --lines 1)" -gt "${greatest_iommu}" ]]; then
    echo -e "Error: Invalid IOMMU group ID(s) specified."

    echo "Please enter a number between '${MIN_IOMMU_VALUE}' and '${greatest_iommu}'."

    exit 1
  fi
}

function verify_vga_group_index
{
  vga_group_index="${1}"

  if [[ -z "${ARGUMENTS["VGA_GROUP_INDEX_TO_MATCH"]}" ]]; then
    return 0
  fi

  for this_vga_group_index in $( \
    echo "${ARGUMENTS["VGA_GROUP_INDEX_TO_MATCH"]}" \
      | sed "s/,/ /g"
  ); do
    if [[ "${this_vga_group_index}" -le "${vga_group_index}" ]]; then
      continue
    fi

    is_quiet_enabled && exit 1
    echo -e "Error: Invalid index specified."

    echo "Please enter a value between '${MIN_VGA_INDEX_VALUE}' and" \
      "'${vga_group_index}'."

    exit 1
  done
}

function main
{
  parse_arguments "${@}"

  local -a group_output=()

  if is_quiet_enabled; then
    parse_groups &> /dev/null
  else
    parse_groups
  fi

  print_output
}

main "$@"