#!/bin/bash

#
# Filename:       parse-iommu-devices
# Description:    Bash script to parse, sort, and display hardware devices by
#                 selected IOMMU group, and return the device drivers and
#                 hardware IDs as output.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
# Version:        1.0.2
#

declare -r SCRIPT_VERSION="1.0.2"
declare -r SCRIPT_NAME="$( basename "${0}" )"
declare -r LOG_FILE="${SCRIPT_NAME}.log"

#
# TODO:
# - [ ] add validation for all inputs.
# - [x] fix output to show every IOMMU group and it's device info.
# - [x] fix lists?
# - [ ] check if all commands used are installed.
# - [ ] ignore groups with vfio.
# - [ ] xml file
#   - hardware ID as primary key.
#   - record one or more driver(s).
#   - if `lspci` differs and is not binded to vfio, update or append.
#   - append new information.
#   - add functionality to sort by driver name?
#  - use this script inside deploy-VFIO.
# - [ ] create logger.
#

#
# TESTS:
# - all operators
# - else?
# - create tests?
#

# set -o xtrace       # debug output.
shopt -s nullglob   # aid with argument inputs.

#
# Terminal formatting
#
  declare -i TABSPACE_WHITESPACE_COUNT=0
  declare -ir THIS_COLUMNS=$( tput cols )
  declare -r USE_WORD_WRAP=true

declare -i MIN_VGA_INDEX_VALUE=1
declare -i MIN_IOMMU_VALUE=0

declare -r NULL_VALUE="N/A"

declare -A ARGUMENTS=(
  ["GET_LESS_OUTPUT"]=false
  ["GET_MINIMUM_OUTPUT"]=false
  ["GROUPS_TO_MATCH"]=""
  ["GROUPS_TO_REVERSE_MATCH"]=""
  ["MATCH_GROUPS"]=false
  ["MATCH_HOST"]=false
  ["MATCH_NAME"]=false
  ["MATCH_PCI"]=false
  ["MATCH_VGA_GROUP_INDEX"]=false
  ["MATCH_TYPE"]=false
  ["MATCH_VENDOR"]=false
  ["NAMES_TO_MATCH"]=""
  ["NAMES_TO_REVERSE_MATCH"]=""
  ["REVERSE_MATCH_GROUPS"]=false
  ["REVERSE_MATCH_NAME"]=false
  ["REVERSE_MATCH_TYPE"]=false
  ["REVERSE_MATCH_VENDOR"]=false
  ["TYPES_TO_MATCH"]=""
  ["TYPES_TO_REVERSE_MATCH"]=""
  ["VENDORS_TO_MATCH"]=""
  ["VENDORS_TO_REVERSE_MATCH"]=""
  ["VGA_GROUP_INDEX_TO_MATCH"]=""
)

declare -A OUTPUTS=(
  ["FOUND_GROUP_ID_LIST"]=""
  ["FOUND_HOST_GROUP_ID_LIST"]=""
  ["FOUND_PCI_GROUP_ID_LIST"]=""
  ["FOUND_VGA_GROUP_ID_LIST"]=""
  ["SELECTED_DRIVER_LIST"]=""
  ["SELECTED_GROUP_ID_LIST"]=""
  ["SELECTED_HARDWARE_ID_LIST"]=""
  ["UNSELECTED_GROUP_ID_LIST"]=""
  ["VFIO_GROUP_ID_LIST"]=""
)

function append_output_to_lists
{
  if "${has_host}"; then
    OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]+="${group_id},"
  fi

  if "${has_pci}"; then
    OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]+="${group_id},"
  fi

  if "${has_vfio}"; then
    OUTPUTS["VFIO_GROUP_ID_LIST"]+="${group_id},"
  fi

  if "${has_vga}"; then
    OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]+="${group_id},"
    (( vga_group_index++ ))
  fi

  if ! "${is_selected}"; then
    OUTPUTS["UNSELECTED_GROUP_ID_LIST"]+="${group_id},"
    return 0
  fi

  OUTPUTS["SELECTED_DRIVER_LIST"]+="${driver_list}"
  OUTPUTS["SELECTED_GROUP_ID_LIST"]+="${group_id},"
  OUTPUTS["SELECTED_HARDWARE_ID_LIST"]+="${hardware_id_list}"
}

function append_output_to_temp_lists
{
  if ! get_minimum_output; then
    if [[ -z "${driver}" ]]; then
      driver="${NULL_VALUE}"
    fi

    local -r tab_prefix="\t\t"
    local -r prefix="${tab_prefix}              "

    local -r hardware_id_output="$( \
      wrap_text \
        true \
        "${prefix}" \
        "${THIS_COLUMNS}" \
        "${tab_prefix}Hardware ID:  ${hardware_id}"
    )"

    local -r name_input="${tab_prefix}Name:         ${name}"

    # FIXME: some names do not appear. Why?
    local name_output="$( \
      wrap_text \
        true \
        "${prefix}" \
        "${THIS_COLUMNS}" \
        "${name_input}"
    )"

    if [[ -z "${name_output}" ]]; then
      name_output="${name_input}"
    fi

    readonly name_output

    local -r type_output="$( \
      wrap_text \
        true \
        "${prefix}" \
        "${THIS_COLUMNS}" \
        "${tab_prefix}Type:         ${type}"
    )"

    local -r vendor_output="$( \
      wrap_text \
        true \
        "${prefix}" \
        "${THIS_COLUMNS}" \
        "${tab_prefix}Vendor:       ${vendor}"
    )"

    group_temp_output+=(
      "\t${device_index}:"
      "${tab_prefix}Slot ID:      ${bus_id}"
      "${vendor_output}"
      "${name_output}"
      "${type_output}"
      "${tab_prefix}Driver:       ${driver}"
      "${hardware_id_output}"
      ""
    )
  fi

  if [[ "${driver}" != "${NULL_VALUE}" ]] \
    && ! [[ ",${driver_list,,}," =~ ",${driver,,}," ]]; then
    driver_list+="${driver},"
  fi

  if [[ "${hardware_id}" != "${NULL_VALUE}" ]] \
    && [[ ",${hardware_id_list,,}," != *",${hardware_id},"* ]]; then
    hardware_id_list+="${hardware_id},"
  fi
}

function create_logfile
{
  if [[ -e "${LOG_FILE}" ]] \
    && ! rm --force "${LOG_FILE}" &> /dev/null; then
    echo -e "Failed to delete logfile."
  fi

  if ! touch "${LOG_FILE}" &> /dev/null; then
    echo -e "Failed to create logfile."
  fi
}

function convert_found_group_id_newline_celimited_list_to_comma_delimited_list
{
  if [[ -z "${OUTPUTS["FOUND_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["FOUND_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["FOUND_GROUP_ID_LIST"]="${OUTPUTS["FOUND_GROUP_ID_LIST"]::-1}"

  OUTPUTS["FOUND_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["FOUND_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_found_host_group_id_newline_celimited_list_to_comma_delimited_list
{
  if [[ -z "${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]::-1}"

  OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_found_pci_group_id_newline_celimited_list_to_comma_delimited_list
{
  if [[ -z "${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]="${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]::-1}"

  OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_found_vga_group_id_newline_celimited_list_to_comma_delimited_list
{
  if [[ -z "${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]::-1}"

  OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_selected_driver_newline_celimited_list_to_comma_delimited_list
{
  if [[ -z "${OUTPUTS["SELECTED_DRIVER_LIST"]}" ]]; then
    OUTPUTS["SELECTED_DRIVER_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["SELECTED_DRIVER_LIST"]="${OUTPUTS["SELECTED_DRIVER_LIST"]::-1}"

  OUTPUTS["SELECTED_DRIVER_LIST"]="$( \
    echo "${OUTPUTS["SELECTED_DRIVER_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_selected_group_id_newline_celimited_list_to_comma_delimited_list
{
  if [[ -z "${OUTPUTS["SELECTED_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["SELECTED_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["SELECTED_GROUP_ID_LIST"]="${OUTPUTS["SELECTED_GROUP_ID_LIST"]::-1}"

  OUTPUTS["SELECTED_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["SELECTED_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_selected_hardware_id_newline_celimited_list_to_comma_delimited_list
{
  if [[ -z "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}" ]]; then
    OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]::-1}"

  OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="$( \
    echo "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_unselected_group_id_newline_celimited_list_to_comma_delimited_list
{
  if [[ -z "${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]::-1}"

  OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_vfio_group_id_newline_celimited_list_to_comma_delimited_list
{
  if [[ -z "${OUTPUTS["VFIO_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["VFIO_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["VFIO_GROUP_ID_LIST"]="${OUTPUTS["VFIO_GROUP_ID_LIST"]::-1}"

  OUTPUTS["VFIO_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["VFIO_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function get_repeated_space
{
  if [[ -z "${1}" ]] \
    || ! [[ "${1}" =~ ^[0-9]+$ ]]; then
    return 1
  fi

  local -i space_count="${1}"
  local output=""

  for index in $( seq 1 "${space_count}" ); do
    output+=" "
  done

  echo -e "${output}"
}

function get_repeated_space_from_tabspace
{
  if [[ -z "${1}" ]] \
    || ! [[ "${1}" =~ ^[0-9]+$ ]]; then
    return 1
  fi

  local -i tabspace_count="$( get_space_count_from_tabspace_count "${1}" )"
  local output=""

  for index in $( seq 1 "${tabspace_count}" ); do
    output+="\t"
  done

  echo -e "${output}"
}

function get_space_count
{
  if [[ -z "${1}" ]]; then
    return 1
  fi

  grep -o ' ' <<<"${1}" \
    | grep -c .
}

function get_space_count_from_tabspace_count
{
  if [[ -z "${1}" ]] \
    || ! [[ "${1}" =~ ^[0-9]+$ ]]; then
    return 1
  fi

  echo -e $(( "${1}" * "${TABSPACE_WHITESPACE_COUNT}" ))
}

function is_comma_delimited_list_of_positive_numbers
{
  if echo "${1}" \
      | grep --extended-regexp --quiet '^(!\d+(,\d+)*$)([^,]+(,[^,]+)*)?$'; then
    print_and_log_output "Error: Input is not a comma delimited list of positive"\
      "numbers."

    return 1
  fi
}

function is_output_not_empty
{
  if [[ "${#group_output[@]}" -lt 1 ]]; then
    return 1
  fi
}

function get_less_output
{
  if ! "${ARGUMENTS["GET_LESS_OUTPUT"]}"; then
    return 1
  fi

  return 0
}

function get_minimum_output
{
  if ! "${ARGUMENTS["GET_MINIMUM_OUTPUT"]}"; then
    return 1
  fi

  return 0
}

function log
{
  local -ir int_return_code="${?}"
  local warn_level="SCRIPT"


  if [[ "${int_return_code}" -ne 0 ]]; then
    warn_level="WARNING"
  fi

  logger -i --tag "${warn_level}" "${LOG_FILE}" "${1}"
  return "${int_return_code}"
}

function parse_arguments
{
  if [[ "${1}" == "-"* ]] \
    && [[ "${1}" != "--"* ]]; then
    for char in $( \
      echo "${1:1}" \
        | sed -e 's/\(.\)/\1\n/g'
    ); do
      argument="-${char}"

      if [[ -z "${argument}" ]]; then
        break
      fi

      parse_argument "${argument}"
    done

    shift
  fi

  parse_argument "${@}"
}

function parse_argument
{
  while [[ ! -z "${1}" ]]; do
    case "${1,,}" in
      "-g" | "--group" )
        ARGUMENTS["MATCH_GROUPS"]=true
        shift

        if ! is_comma_delimited_list_of_positive_numbers "${1}" \
          || [[ "${1}" -lt "${MIN_IOMMU_VALUE}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["GROUPS_TO_MATCH"]="${1}"
        ;;

      "-H" | "--host" )
        ARGUMENTS["MATCH_HOST"]=true
        ;;

      "--ignore-group" )
        ARGUMENTS["REVERSE_MATCH_GROUPS"]=""
        shift

        if ! is_comma_delimited_list_of_positive_numbers "${1}" \
          || [[ "${1}" -lt "${MIN_IOMMU_VALUE}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]="${1}"
        ;;

      "--ignore-name" )
        ARGUMENTS["REVERSE_MATCH_NAME"]=true
        shift

        if [[ -z "${1}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["NAMES_TO_REVERSE_MATCH"]="${1}"
        ;;

      "--ignore-type" )
        ARGUMENTS["REVERSE_MATCH_TYPE"]=true
        shift

        if [[ -z "${1}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["TYPES_TO_REVERSE_MATCH"]="${1}"
        ;;

      "--ignore-vendor" )
        ARGUMENTS["REVERSE_MATCH_VENDOR"]=true
        shift

        if [[ -z "${1}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["VENDORS_TO_REVERSE_MATCH"]="${1}"
        ;;

      "-n" | "--name" )
        ARGUMENTS["MATCH_NAME"]=true
        shift

        if [[ -z "${1}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["NAMES_TO_MATCH"]="${1}"
        ;;

      "-p" | "--pci" | "--pcie" )
        ARGUMENTS["MATCH_PCI"]=true
        ;;

      "-q" | "--quiet" )
        ARGUMENTS["GET_LESS_OUTPUT"]=true
        ;;

      "-qq" | "--quieter" )
        ARGUMENTS["GET_MINIMUM_OUTPUT"]=true
        ;;

      "-t" | "--type" )
        ARGUMENTS["MATCH_TYPE"]=true
        shift

        if [[ -z "${1}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["TYPES_TO_MATCH"]="${1}"
        ;;

      "-v" | "--vendor" )
        ARGUMENTS["MATCH_VENDOR"]=true
        shift

        if [[ -z "${1}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["VENDORS_TO_MATCH"]="${1}"
        ;;

      "-V" | "--vga-index" )
        ARGUMENTS["MATCH_VGA_GROUP_INDEX"]=true
        shift

        if ! is_comma_delimited_list_of_positive_numbers "${1}" \
          || [[ "${1}" -lt "${MIN_VGA_INDEX_VALUE}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["VGA_GROUP_INDEX_TO_MATCH"]="${1}"
        ;;

      "" )
        return 0
        ;;

      "-h" | "--help" )
        print_usage
        exit 2
        ;;

      * )
        print_invalid_argument
        ;;

    esac

    shift
  done
}

function parse_this_group_devices
{
  is_selected=false
  bus_id=""
  driver=""
  hardware_id=""
  name=""
  type=""
  vendor=""

  set_device_properties
  set_group_properties
  set_name_match_property
  set_name_reverse_match_property
  set_type_match_property
  set_type_reverse_match_property
  set_vendor_match_property
  set_vendor_reverse_match_property
  set_vfio_match_property
  set_vga_type_match_property

  if "${has_vfio}";then
    return 1
  fi

  append_output_to_temp_lists

  if "${ARGUMENTS["MATCH_HOST"]}" \
      && ! "${has_host}"; then
    return 1
  fi

  if "${ARGUMENTS["MATCH_PCI"]}" \
      && ! "${has_pci}"; then
    return 1
  fi

  if "${ARGUMENTS["MATCH_NAME"]}" \
      && ! "${has_name}"; then
    return 1
  fi

  if "${ARGUMENTS["MATCH_TYPE"]}" \
      && ! "${has_type}"; then
    return 1
  fi

  if "${ARGUMENTS["MATCH_VENDOR"]}" \
      && ! "${has_vendor}"; then
    return 1
  fi

  if "${ARGUMENTS["REVERSE_MATCH_NAME"]}" \
      && "${has_name_reverse_match}"; then
    return 1
  fi

  if "${ARGUMENTS["REVERSE_MATCH_TYPE"]}" \
      && "${has_type_reverse_match}"; then
    return 1
  fi

  if "${ARGUMENTS["REVERSE_MATCH_VENDOR"]}" \
      && "${has_vendor_reverse_match}"; then
    return 1
  fi

  if "${ARGUMENTS["MATCH_VGA_GROUP_INDEX"]}" \
      && ! "${has_vga}"; then
    return 1
  fi

  is_selected=true
}

function parse_this_group
{
  group_id="${group##*/}"
  OUTPUTS["FOUND_GROUP_ID_LIST"]+="${group_id},"

  if ! get_minimum_output; then
    group_output+=( "IOMMU Group ${group_id}:" )
  fi

  device_index=0
  group_id_list=""
  driver_list=""
  hardware_id_list=""
  has_host=false
  has_pci=false
  has_name=false
  has_name_reverse_match=false
  has_type=false
  has_type_reverse_match=false
  has_vendor=false
  has_vendor_reverse_match=false
  has_vfio=false
  has_vga=false
  is_selected=false
  local -a group_temp_output=()

  for device in ${group##}/devices/*; do
    parse_this_group_devices || continue

    if [[ ",${group_id_list,,}," != *",${group_id},"* ]]; then
      group_id_list+="${group_id},"
    fi
  done

  if ! get_minimum_output; then
    if [[ "${#group_temp_output[@]}" -lt 1 ]]; then
      group_output+=(
        "\tNo devices matched or found for group ${group_id}."
        ""
      )
    else
      group_output+=( "${group_temp_output[@]}" )
    fi
  fi
}

function parse_many_groups
{
  local -i vga_group_index=0

  for group in $( \
    find /sys/kernel/iommu_groups/* -maxdepth 0 -type d \
      | sort --version-sort
  ); do
    parse_this_group
    append_output_to_lists
  done

  if ! verify_vga_group_index "${vga_group_index}"; then
    return 1
  fi

  convert_found_group_id_newline_celimited_list_to_comma_delimited_list
  convert_found_host_group_id_newline_celimited_list_to_comma_delimited_list
  convert_found_pci_group_id_newline_celimited_list_to_comma_delimited_list
  convert_found_vga_group_id_newline_celimited_list_to_comma_delimited_list
  convert_selected_driver_newline_celimited_list_to_comma_delimited_list
  convert_selected_group_id_newline_celimited_list_to_comma_delimited_list
  convert_selected_hardware_id_newline_celimited_list_to_comma_delimited_list
  convert_unselected_group_id_newline_celimited_list_to_comma_delimited_list
  convert_vfio_group_id_newline_celimited_list_to_comma_delimited_list
}

function print_and_log_output
{
  local -ir int_return_code="${?}"

  if [[ "${int_return_code}" -ne 0 ]]; then
    log "${1}"
  fi

  if ! get_minimum_output; then
    echo -e "${1}" >&1
  fi

  return "${int_return_code}"
}

function print_invalid_argument
{
  get_minimum_output && exit 1
  print_and_log_output "Error: Invalid argument(s) specified."
  print_usage
  exit 1
}

function print_invalid_option
{
  get_minimum_output && exit 1
  print_and_log_output "Error: Invalid option specified."
  print_usage
  exit 1
}

function print_groups_output
{
  if ! get_less_output; then
    if ! is_output_not_empty; then
      print_and_log_output "Error: No IOMMU groups found."
      return 1
    fi

    for line in "${group_output[@]}"; do
      print_and_log_output "${line}"
    done
  fi

  print_and_log_output "Found Groups:\n${OUTPUTS["FOUND_GROUP_ID_LIST"]}\n"

  print_and_log_output \
    "Found Groups with Host device(s):\n${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}\n"

  print_and_log_output \
    "Found Groups with PCI device(s):\n${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]}\n"

  print_and_log_output \
    "Found Groups with VGA device(s):\n${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}\n"

  print_and_log_output \
    "Unselected Groups:\n${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}\n"

  print_and_log_output \
    "Unselected Groups binded to VFIO:\n${OUTPUTS["VFIO_GROUP_ID_LIST"]}\n"

  print_and_log_output \
    "Selected Groups:\n${OUTPUTS["SELECTED_GROUP_ID_LIST"]}\n"

  #
  # NOTE: Print hardware IDs first, as this value is never null, but drivers
  #       may be. Should a user rely on the output as input, the user may only
  #       have to validate if $2 is null or not. Otherwise, the user would have
  #       to validate by regex, which is not nice.
  #

  print_and_log_output \
    "Selected Hardware IDs:\n${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}\n"

  print_and_log_output "Selected Drivers:\n${OUTPUTS["SELECTED_DRIVER_LIST"]}"

  if ! get_minimum_output; then
    return 0
  fi

  print_and_log_output "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}"
  print_and_log_output "${OUTPUTS["SELECTED_DRIVER_LIST"]}"
}

function print_usage
{
  if get_minimum_output; then
    return 0
  fi

  local -r column_prefix_count=28

  echo -e "Usage:\t${SCRIPT_NAME} [ARGUMENTS]"
  echo
  echo -e "Parse, sort, and display hardware devices by IOMMU group(s)."
  echo -e "Version ${SCRIPT_VERSION}."
  echo
  echo -e "  -h, --help                Print this help and exit."

  echo -en "  -q, --quiet               "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "Quiet most output except for IOMMU groups output, and lists of device drivers"\
      "and hardware IDs."

  echo -en "  -qq, --very-quiet         "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "Quiet all output except for lists of device drivers and hardware IDs."

  echo -en "  -g, --group=GROUPS        "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "Match IOMMU group ID(s);"

  echo -en "$( get_repeated_space 28 )"

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "GROUPS is a comma delimited list of numbers."

  echo -en "  --ignore-group=GROUPS     "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "Reverse match IOMMU group ID(s);"

  echo -en "$( get_repeated_space 28 )"

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "GROUPS is a comma delimited list of numbers."

  echo -en "  -H, --host                "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "Match IOMMU groups with at least one (1) or more Host devices."

  echo -en "  --ignore-name=NAME        "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "Match IOMMU group(s) without device name, overrides "--name";"

  echo -en "                            "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "NAME is a comma delimited list of text."

  echo -en "  --ignore-type=TYPE        "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "Match IOMMU group(s) without device type, overrides "--type";"

  echo -en "                            "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "TYPE is a comma delimited list of text."

  echo -en "  --ignore-vendor=VENDOR    "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "Match IOMMU group(s) without device vendor, overrides "--vendor";"

  echo -en "                            "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "VENDOR is a comma delimited list of text."

  echo -en "  -n, --name=NAME           "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "Match IOMMU group(s) with device name;"

  echo -en "$( get_repeated_space 28 )"

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "NAME is a comma delimited list of text."

  echo -en "  -t, --type=TYPE           "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "Match IOMMU group(s) with device type;"

  echo -en "$( get_repeated_space 28 )"

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "TYPE is a comma delimited list of text."

  echo -en "  -v, --vendor=VENDOR       "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "Match IOMMU group(s) with device vendor;"

  echo -en "$( get_repeated_space 28 )"

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "VENDOR is a comma delimited list of text."

  echo -en "  -p, --pci, --pcie         "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "Match IOMMU groups with at least one (1) or more PCI/PCIe bus devices."

  echo -en "  -V, --vga-index=INDEX     "

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "Match all IOMMU groups without VGA," \
    "and any with VGA which match the index value(s) (not an IOMMU group ID);"

  echo -en "$( get_repeated_space 28 )"

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "INDEX is a comma delimited list of numbers."

  echo
  echo -e "Examples:"

  echo -e "  ${SCRIPT_NAME} --ignore-name ether --pcie -qq -v 2"
  echo -en "                            "

  text="Quiet output except for drivers and "
  text+="hardware IDs (of IOMMU groups with PCI/e devices), exclude IOMMU "
  text+="groups with VGA device(s) before and after the second matched group, "
  text+="and exclude any wired ethernet devices (Host and PCI/e)."

  wrap_text \
    false \
    "${column_prefix_count}" \
    "${THIS_COLUMNS}" \
    "${text}"
}

function set_device_properties
{
  (( device_index++ ))

  bus_id="$( \
    lspci -ns ${device##*/} \
      | awk 'END {print $1}' \
  )"

  driver="$( \
    lspci -ks ${device##*/} \
      | grep driver \
      | awk 'END {print $5}' \
  )"

  hardware_id="$( \
    lspci -ns ${device##*/} \
      | awk 'END {print $3}' \
  )"

  name="$( \
    lspci -ms ${device##*/} \
      | cut --delimiter '"' --fields 6 \
  )"

  type="$( \
    lspci -ms ${device##*/} \
      | cut --delimiter '"' --fields 2 \
  )"

  vendor="$( \
    lspci -ms ${device##*/} \
      | cut --delimiter '"' --fields 4 \
  )"
}

function set_group_properties
{
  internal_bus_id="00"
  this_bus_id="${bus_id::2}"

  if [[ "${this_bus_id}" == "${internal_bus_id}" ]]; then
    has_host=true
  else
    has_pci=true
  fi
}

function set_name_match_property
{
  if "${has_name}" \
    || ! "${ARGUMENTS["MATCH_NAME"]}"; then
    return 0
  fi

  for this_name in $( \
    echo "${ARGUMENTS["NAMES_TO_MATCH"]}" \
      | sed "s/,/ /g"
  ); do
    if [[ "${name,,}" =~ "${this_name,,}" ]]; then
      has_name=true
      break
    fi
  done
}

function set_name_reverse_match_property
{
  if "${has_name_reverse_match}" \
    || ! "${ARGUMENTS["REVERSE_MATCH_NAME"]}"; then
    return 0
  fi

  for this_name in $( \
    echo "${ARGUMENTS["NAMES_TO_REVERSE_MATCH"]}" \
      | sed "s/,/ /g" \
  ); do
    if [[ "${name,,}" =~ "${this_name,,}" ]]; then
      has_name_reverse_match=true
      break
    fi
  done
}

function set_type_match_property
{
  if "${has_type}" \
    || ! "${ARGUMENTS["MATCH_TYPE"]}"; then
    return 0
  fi

  for this_type in $( \
    echo "${ARGUMENTS["TYPES_TO_MATCH"]}" \
      | sed "s/,/ /g"
  ); do
    if [[ "${type,,}" =~ "${this_type,,}" ]]; then
      has_type=true
      break
    fi
  done
}

function set_type_reverse_match_property
{
  if "${has_type_reverse_match}" \
    || ! "${ARGUMENTS["REVERSE_MATCH_TYPE"]}"; then
    return 0
  fi

  for this_type in $( \
    echo "${ARGUMENTS["TYPES_TO_REVERSE_MATCH"]}" \
      | sed "s/,/ /g" \
  ); do
    if [[ "${type,,}" =~ "${this_type,,}" ]]; then
      has_type_reverse_match=true
      break
    fi
  done
}

function set_vendor_match_property
{
  if "${has_vendor}" \
    || ! "${ARGUMENTS["MATCH_VENDOR"]}"; then
    return 0
  fi

  for this_vendor in $( \
    echo "${ARGUMENTS["VENDORS_TO_REVERSE_MATCH"]}" \
      | sed "s/,/ /g" \
  ); do
    if [[ "${vendor,,}" =~ "${this_vendor,,}" ]]; then
      has_vendor=true
      break
    fi
  done
}

function set_vendor_reverse_match_property
{
  if "${has_vendor_reverse_match}" \
    || ! "${ARGUMENTS["REVERSE_MATCH_VENDOR"]}"; then
    return 0
  fi

  for this_vendor in $( \
    echo "${ARGUMENTS["VENDORS_TO_REVERSE_MATCH"]}" \
      | sed "s/,/ /g" \
  ); do
    if [[ "${vendor,,}" =~ "${this_vendor,,}" ]]; then
      has_vendor_reverse_match=true
      break
    fi
  done
}

function set_tabspace_size
{
  if [[ "${THIS_COLUMNS}" -lt 16 ]]; then
    TABSPACE_WHITESPACE_COUNT=1
  fi

  if [[ "${THIS_COLUMNS}" -gt 32 ]]; then
    TABSPACE_WHITESPACE_COUNT=2
  fi

  if [[ "${THIS_COLUMNS}" -gt 64 ]]; then
    TABSPACE_WHITESPACE_COUNT=4
  fi

  if [[ "${THIS_COLUMNS}" -gt 96 ]]; then
    TABSPACE_WHITESPACE_COUNT=8
  fi

  tabs "${TABSPACE_WHITESPACE_COUNT}"
}

function set_vfio_match_property
{
  if echo "${driver,,}" \
      | grep --quiet "stub" \
    || echo "${driver,,}" \
      | grep --quiet "vfio"; then
    has_vfio=true
  fi
}

function set_vga_type_match_property
{
  if echo "${type,,}" \
      | grep --quiet "vga"; then
    has_vga=true
  fi
}

function verify_groups
{
  local -i greatest_iommu="$( \
    ls /sys/kernel/iommu_groups/ \
      | sort --reverse --version-sort \
      | head --lines 1
  )"

  local warning="Error: Invalid IOMMU group ID(s) specified. Please enter a "
  warning+="number between '${MIN_IOMMU_VALUE}' and '${greatest_iommu}'."

  if ! is_comma_delimited_list_of_positive_numbers \
      "${ARGUMENTS["GROUPS_TO_MATCH"]}" \
    || [[ "$( \
      echo "${ARGUMENTS["GROUPS_TO_MATCH"]}" \
        | sort --reverse --version-sort \
        | head --lines 1 \
      )" -gt "${greatest_iommu}" ]]; then
    print_and_log_output "${warning}"
    return 1
  fi

  if ! is_comma_delimited_list_of_positive_numbers \
      "${ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]}" \
    || [[ "$( \
      echo "${ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]}" \
        | sort --reverse --version-sort \
        | head --lines 1 \
      )" -gt "${greatest_iommu}" ]]; then
    print_and_log_output "${warning}"
    return 1
  fi
}

function verify_vga_group_index
{
  vga_group_index="${1}"

  if [[ -z "${ARGUMENTS["VGA_GROUP_INDEX_TO_MATCH"]}" ]]; then
    return 0
  fi

  for this_vga_group_index in $( \
    echo "${ARGUMENTS["VGA_GROUP_INDEX_TO_MATCH"]}" \
      | sed "s/,/ /g"
  ); do
    if [[ "${this_vga_group_index}" -le "${vga_group_index}" ]]; then
      continue
    fi

    if get_minimum_output; then
      return 1
    fi

    print_and_log_output "Error: Invalid index specified."

    print_and_log_output \
      "Please enter a value between '${MIN_VGA_INDEX_VALUE}' and" \
      "'${vga_group_index}'."

    return 1
  done
}

function wrap_text
{
  local -r use_tab_space="${1}"

  if [[ -z "${1}" ]]; then
    return 1
  fi

  shift

  local prefix_width="${1}"

  if [[ -z "${1}" ]]; then
    return 1
  fi

  shift
  local -i column_width="${1}"

  if [[ -z "${1}" ]]; then
    return 1
  fi

  shift

  if ! "${USE_WORD_WRAP}"\
    || ! [[ "${column_width}" =~ ^[0-9]+$ ]]; then
    echo -e "$@"
    return
  fi

  if ! [[ "${prefix_width}" =~ ^[0-9]+$ ]]; then
    local prefix_text="${prefix_width}"
  else
    if "${use_tab_space}"; then
      prefix_width="$( get_space_count_from_tabspace_count "${prefix_width}" )"
    fi

    local prefix_text="$( get_repeated_space "${prefix_width}" )"

    if [[ "${prefix_width}" -gt ${column_width} ]]; then
      column_width=$(( ${prefix_width} - ${column_width} ))
    else
      column_width=$(( ${column_width} - ${prefix_width} ))
    fi
  fi

  set -o noglob
  IFS=$'\n'
  set +o noglob
  local -a lines="$( \
    echo "${@}" \
      | fold --spaces --width="${column_width}" \
  )"

  lines=(${lines[@]})
  echo -e "${lines[0]}"
  unset 'lines[0]'

  for line in "${lines[@]}"; do
    echo -en "${prefix_text}"

    echo -e "${line}" \
      | sed 's/^[ \t]*//;s/[ \t]*$//'
  done

  unset IFS
}



function main
{
  set_tabspace_size
  create_logfile
  log "${0} ${@}"
  parse_arguments "${@}"

  if ! verify_groups; then
    return 1
  fi

  local -r message="Parsing hardware devices..."

  local -a group_output=()
  print_and_log_output "${message}"

  if ! parse_many_groups; then
    print_and_log_output "${message} Failed."
    return 1
  fi

  print_and_log_output "${message} Successful.\n"
  print_groups_output
}

main "$@"