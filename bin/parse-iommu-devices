#!/bin/bash

#
# Filename:       parse-iommu-devices
# Description:    Bash script to parse, sort, and display hardware devices by
#                 selected IOMMU group, and return the device drivers and
#                 hardware IDs as output.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
# Version:        1.0.2
#

#
# TODO:
# - [ ] add validation for all inputs.
# - [x] fix output to show every IOMMU group and it's device info.
# - [x] fix lists?
#

shopt -s nullglob

declare -r SCRIPT_VERSION="1.0.2"
declare -r SCRIPT_NAME="$( basename "${0}" )"
declare -i MIN_VGA_INDEX_VALUE=1
declare -i MIN_IOMMU_VALUE=0
declare -ir THIS_COLUMNS=$( tput cols )
declare -r USE_WORD_WRAP=true

declare -A ARGUMENTS=(
  ["GET_MINIMUM_OUTPUT"]=false
  ["GROUPS_TO_MATCH"]=""
  ["GROUPS_TO_REVERSE_MATCH"]=""
  ["MATCH_GROUPS"]=false
  ["MATCH_HOST"]=false
  ["MATCH_NAMES"]=false
  ["MATCH_PCI"]=false
  ["MATCH_VGA_GROUP_INDEX"]=false
  ["NAMES_TO_MATCH"]=""
  ["NAMES_TO_REVERSE_MATCH"]=""
  ["REVERSE_MATCH_GROUPS"]=false
  ["REVERSE_MATCH_NAMES"]=false
  ["VGA_GROUP_INDEX_TO_MATCH"]=""
)

declare -A OUTPUTS=(
  ["FOUND_GROUP_ID_LIST"]=""
  ["FOUND_HOST_GROUP_ID_LIST"]=""
  ["FOUND_PCI_GROUP_ID_LIST"]=""
  ["FOUND_VGA_GROUP_ID_LIST"]=""
  ["SELECTED_DRIVERS"]=""
  ["SELECTED_GROUP_ID_LIST"]=""
  ["SELECTED_HARDWARE_ID_LIST"]=""
  ["UNSELECTED_GROUP_ID_LIST"]=""
)

function append_output_to_lists
{
  if "${has_host}"; then
    OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]+="${group_id},"
  fi

  if "${has_pci}"; then
    OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]+="${group_id},"
  fi

  if "${has_vga}"; then
    OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]+="${group_id},"
    (( vga_group_index++ ))
  fi

  if ! "${is_selected}"; then
    OUTPUTS["UNSELECTED_GROUP_ID_LIST"]+="${group_id},"
    return 0
  fi

  OUTPUTS["SELECTED_DRIVERS"]+="${driver_list}"
  OUTPUTS["SELECTED_GROUP_ID_LIST"]+="${group_id},"
  OUTPUTS["SELECTED_HARDWARE_ID_LIST"]+="${hardware_id_list}"
}

function append_output_to_temp_lists
{
  if ! is_quiet_enabled; then
    local driver_output="\t\tDriver:\t\t"

    if [[ ! -z "${driver}" ]]; then
      driver_output+="${driver}"
    else
      driver_output+="N/A"
    fi

    name_output="$( \
      echo "${name}" \
        | fmt --crown-margin \
    )"

    group_temp_output+=(
      "\t${device_index}.\tSlot ID:\t${bus_id}"
      "\t\tName:\t\t${name_output}"
      "\t\tHardware ID:\t${hardware_id}"
      "${driver_output}"
    )

    group_temp_output+=( "" )
  fi

  if [[ ",${driver_list,,}," != *",${driver},"* ]]; then
    driver_list+="${driver},"
  fi

  if [[ ",${hardware_id_list,,}," != *",${hardware_id},"* ]]; then
    hardware_id_list+="${hardware_id},"
  fi
}

function convert_found_group_id_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["FOUND_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["FOUND_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["FOUND_GROUP_ID_LIST"]="${OUTPUTS["FOUND_GROUP_ID_LIST"]::-1}"

  OUTPUTS["FOUND_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["FOUND_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_found_host_group_id_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]::-1}"

  OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_found_pci_group_id_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]="${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]::-1}"

  OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_found_vga_group_id_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]::-1}"

  OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_selected_driver_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["SELECTED_DRIVERS"]}" ]]; then
    OUTPUTS["SELECTED_DRIVERS"]="N/A"
    return 0
  fi

  OUTPUTS["SELECTED_DRIVERS"]="${OUTPUTS["SELECTED_DRIVERS"]::-1}"

  OUTPUTS["SELECTED_DRIVERS"]="$( \
    echo "${OUTPUTS["SELECTED_DRIVERS"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_selected_group_id_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["SELECTED_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["SELECTED_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["SELECTED_GROUP_ID_LIST"]="${OUTPUTS["SELECTED_GROUP_ID_LIST"]::-1}"

  OUTPUTS["SELECTED_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["SELECTED_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_selected_hardware_id_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}" ]]; then
    OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]::-1}"

  OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="$( \
    echo "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function convert_unselected_group_id_list_to_delimited_string
{
  if [[ -z "${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}" ]]; then
    OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="N/A"
    return 0
  fi

  OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]::-1}"

  OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="$( \
    echo "${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}" \
      | sed --expression $'s/,/\\\n/g' \
      | sort --numeric-sort \
      | tr '\n' ',' \
      | sed 's/.$//' \
      | tr ',' '\n' \
      | sort --human-numeric-sort --unique \
      | xargs \
      | tr ' ' ','
  )"
}

function is_comma_delimited_list_of_positive_numbers
{
  if echo "${1}" \
      | grep --extended-regexp --quiet '^(!\d+(,\d+)*$)([^,]+(,[^,]+)*)?$'; then
    echo -e "Error: Input is not a comma delimited list of positive numbers."
    return 1
  fi
}

function is_output_not_empty
{
  if [[ "${#group_output[@]}" -lt 1 ]]; then
    return 1
  fi
}

function is_quiet_enabled
{
  if ! "${ARGUMENTS["GET_MINIMUM_OUTPUT"]}"; then
    return 1
  fi

  return 0
}

function parse_arguments
{
  if [[ "${1}" == "-"* ]] \
    && [[ "${1}" != "--"* ]]; then
    for char in $( \
      echo "${1:1}" \
        | sed -e 's/\(.\)/\1\n/g'
    ); do
      argument="-${char}"

      if [[ -z "${argument}" ]]; then
        break
      fi

      parse_argument "${argument}"
    done

    shift
  fi

  parse_argument "${@}"
}

function parse_argument
{
  while [[ ! -z "${1}" ]]; do
    case "${1,,}" in
      "-g" | "--group" )
        ARGUMENTS["MATCH_GROUPS"]=true
        shift

        if ! is_comma_delimited_list_of_positive_numbers "${1}" \
          || [[ "${1}" -lt "${MIN_IOMMU_VALUE}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["GROUPS_TO_MATCH"]="${1}"
        ;;

      "-H" | "--host" )
        ARGUMENTS["MATCH_HOST"]=true
        ;;

      "--ignore-group" )
        ARGUMENTS["REVERSE_MATCH_GROUPS"]=""
        shift

        if ! is_comma_delimited_list_of_positive_numbers "${1}" \
          || [[ "${1}" -lt "${MIN_IOMMU_VALUE}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]="${1}"
        ;;

      "--ignore-name" )
        ARGUMENTS["REVERSE_MATCH_NAMES"]=true
        shift

        if [[ -z "${1}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["NAMES_TO_REVERSE_MATCH"]="${1}"
        ;;

      "-p" | "--pci" | "--pcie" )
        ARGUMENTS["MATCH_PCI"]=true
        ;;

      "-q" | "--quiet" )
        ARGUMENTS["GET_MINIMUM_OUTPUT"]=true
        ;;

      "-v" | "--vga-index" )
        ARGUMENTS["MATCH_VGA_GROUP_INDEX"]=true
        shift

        if ! is_comma_delimited_list_of_positive_numbers "${1}" \
          || [[ "${1}" -lt "${MIN_VGA_INDEX_VALUE}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["VGA_GROUP_INDEX_TO_MATCH"]="${1}"
        ;;

    "-n" | "--name" )
        ARGUMENTS["MATCH_NAMES"]=true
        shift

        if [[ -z "${1}" ]]; then
          print_invalid_option
        fi

        ARGUMENTS["NAMES_TO_MATCH"]="${1}"
        ;;

      "" )
        return 0
        ;;

      "-h" | "--help" )
        print_usage
        exit 2
        ;;

      * )
        print_invalid_argument
        ;;

    esac

    shift
  done
}

function parse_group_devices
{
  set_device_properties
  set_group_properties
  set_name_match_property
  set_reverse_name_match_property
  set_vga_type_match_property

  if "${ARGUMENTS["MATCH_HOST"]}" \
      && ! "${has_host}" \
      && ! "${ARGUMENTS["MATCH_PCI"]}"; then
    return 1
  fi

  if "${ARGUMENTS["MATCH_PCI"]}" \
      && ! "${has_pci}" \
      && ! "${ARGUMENTS["MATCH_HOST"]}"; then
    return 1
  fi

  if "${ARGUMENTS["MATCH_NAMES"]}" \
      && ! "${has_name}" \
      && ! "${ARGUMENTS["REVERSE_MATCH_NAMES"]}"; then
    return 1
  fi

  if "${ARGUMENTS["REVERSE_MATCH_NAMES"]}" \
      && ! "${has_reverse_name}" \
      && ! "${ARGUMENTS["MATCH_NAMES"]}"; then
    return 1
  fi

  if "${ARGUMENTS["MATCH_VGA_GROUP_INDEX"]}" \
      && ! "${has_vga}"; then
    return 1
  fi

  is_selected=true
  append_output_to_temp_lists
}

function parse_group
{
  group_id="${group##*/}"
  OUTPUTS["FOUND_GROUP_ID_LIST"]+="${group_id},"

  if ! is_quiet_enabled; then
    group_output+=(
      "IOMMU Group ${group_id}:"
    )
  fi

  device_index=0
  group_id_list=""
  driver_list=""
  hardware_id_list=""
  has_host=false
  has_pci=false
  has_name=false
  has_reverse_name=false
  has_vga=false
  is_selected=false
  local -a group_temp_output=()

  if [[ ! -z "${ARGUMENTS["GROUPS_TO_MATCH"]}" ]] \
    && ! echo "${ARGUMENTS["GROUPS_TO_MATCH"]}" \
      | grep --quiet "${group_id}"; then
    if ! is_quiet_enabled; then
      group_output[-1]+="\tNot matched.\n"
    fi

    return 1
  fi

  if [[ ! -z "${ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]}" ]] \
      && echo "${ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]}" \
        | grep --quiet "${group_id}"; then
    if ! is_quiet_enabled; then
      group_output[-1]+="\tSkipped.\n"
    fi

    return 1
  fi

  for device in ${group##}/devices/*; do
    parse_group_devices

    if [[ ",${group_id_list,,}," != *",${group_id},"* ]]; then
      group_id_list+="${group_id},"
    fi
  done

  if ! is_quiet_enabled; then
    if [[ "${#group_temp_output[@]}" -lt 1 ]]; then
      group_output+=( "\tNo devices found for group ${group_id}." )
      exit 1
    else
      group_output+=( "${group_temp_output[@]}" )
    fi
  fi
}

function parse_groups
{
  local -i vga_group_index=0

  for group in $( \
    find /sys/kernel/iommu_groups/* -maxdepth 0 -type d \
      | sort --version-sort
  ); do
    parse_group
    append_output_to_lists
  done

  verify_vga_group_index "${vga_group_index}"
  convert_found_group_id_list_to_delimited_string
  convert_found_host_group_id_list_to_delimited_string
  convert_found_pci_group_id_list_to_delimited_string
  convert_found_vga_group_id_list_to_delimited_string
  convert_selected_driver_list_to_delimited_string
  convert_selected_group_id_list_to_delimited_string
  convert_selected_hardware_id_list_to_delimited_string
  convert_unselected_group_id_list_to_delimited_string
}

function print_invalid_argument
{
  is_quiet_enabled && exit 1
  echo -e "Error: Invalid argument(s) specified."
  print_usage
  exit 1
}

function print_invalid_option
{
  is_quiet_enabled && exit 1
  echo -e "Error: Invalid option specified."
  print_usage
  exit 1
}

function print_output
{
  if is_quiet_enabled; then
    echo -e "${OUTPUTS["SELECTED_DRIVERS"]}"
    echo -e "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}"
    return 0
  fi

  if ! is_output_not_empty; then
    echo -e "Error: No IOMMU groups found."
    return 1
  fi

  for line in "${group_output[@]}"; do
    echo -e "${line}"
  done

  # echo -e "Found Groups:\t\t${OUTPUTS["FOUND_GROUP_ID_LIST"]}"
  # echo
  echo -e "Unselected Groups:\t${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}"
  echo
  echo -e "Selected Groups:\t${OUTPUTS["SELECTED_GROUP_ID_LIST"]}"
  echo
  echo -e "Selected Groups with Host device(s):\t${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}"
  echo
  echo -e "Selected Groups with PCI device(s):\t${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]}"
  echo
  echo -e "Selected Groups with VGA device(s):\t${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}"
  echo
  echo -e "Selected Drivers:\n${OUTPUTS["SELECTED_DRIVERS"]}"
  echo
  echo -e "Selected Hardware IDs:\n${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}"
}

function print_usage
{
  if is_quiet_enabled; then
    return 0
  fi

  local -r column_prefix_count=28

  echo -e "Usage:\t${SCRIPT_NAME} [ARGUMENTS]"
  echo
  echo -e "Parse, sort, and display hardware devices by IOMMU group(s)."
  echo -e "Version ${SCRIPT_VERSION}."
  echo

  echo -e "  -h, --help                "
  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "Print this help and exit."

  echo -en "  -q, --quiet               "

  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "Quiet all output except for comma delimited lists of device drivers and hardware IDs."

  echo -en "  -g, --group=GROUPS        "
  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "Match IOMMU group ID(s);"

  echo -en "                            "
  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "GROUPS is a comma delimited list of" \
    "numbers."

  echo -en "  --ignore-group=GROUPS     "
  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "Reverse match IOMMU group ID(s);"

  echo -en "                            "
  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "GROUPS is a comma delimited list of" \
    "numbers.D"

  echo -en "  -H, --host                "

  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "Match IOMMU groups with at least one" \
    "(1) or more Host devices."

  echo -en "  --ignore-name=NAME        "

  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "Match IOMMU group(s) without device" \
    "name;"

  echo -en "                            "
  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "NAME is a comma delimited list of" \
    "text."

  echo -en "  -n, --name=NAME           "

  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "Match IOMMU group(s) with device" \
    "name;"

  echo -en "                            "

  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "NAME is a comma delimited list of" \
    "text."

  echo -en "  -p, --pci, --pcie         "

  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "Match IOMMU groups with at least one" \
    "(1) or more PCI and/or PCIe bus devices."

  echo -en "  -v, --vga-index=INDEX     "

  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "Match all IOMMU groups without VGA," \
    "and any with VGA which match the index value(s) (not an IOMMU group ID);"

  echo -en "                            "

  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "INDEX is a comma delimited list of" \
    "numbers."

  echo
  echo -e "Examples:"

  echo -e "  ${SCRIPT_NAME} --ignore-name ether --pcie -q -v 2"
  echo -en "                            "

  wrap_text "${column_prefix_count}" "${THIS_COLUMNS}" "Quiet output except for drivers and" \
  "hardware IDs (of IOMMU groups with PCI/e devices), exclude IOMMU" \
  "groups with VGA device(s) before and after the second matched group, and" \
  "exclude any wired ethernet devices (onboard or PCI/e)."
}

function set_device_properties
{
  (( device_index++ ))
  name="$( lspci -s ${device##*/} )"
  name="${name:8}"
  name="$( wrap_text 33 "${THIS_COLUMNS}" "${name}" )"

  bus_id="$( \
    lspci -ns ${device##*/} \
      | awk 'END {print $1}'
  )"

  hardware_id="$( \
    lspci -ns ${device##*/} \
      | awk 'END {print $3}'
  )"

  driver="$( \
    lspci -kns ${device##*/} \
      | grep "driver" \
      | awk 'END {print $5}'
  )"
}

function set_group_properties
{
  internal_bus_id="00"
  this_bus_id="${bus_id::2}"

  if [[ "${this_bus_id}" == "${internal_bus_id}" ]]; then
    has_host=true
  else
    has_pci=true
  fi
}

function set_name_match_property
{
  if "${has_name}" \
    || ! "${ARGUMENTS["MATCH_NAMES"]}"; then
    return 0
  fi

  for this_name in $( \
    echo "${ARGUMENTS["NAMES_TO_MATCH"]}" \
      | sed "s/,/ /g"
  ); do
    if echo "${name,,}" \
        | grep --invert-match --quiet "${this_name,,}"; then
      continue
    fi

    has_name=true
  done
}

function set_reverse_name_match_property
{
  if "${has_reverse_name}" \
    || ! "${ARGUMENTS["REVERSE_MATCH_NAMES"]}"; then
    return 0
  fi

  for this_name in $( \
    echo "${ARGUMENTS["NAMES_TO_REVERSE_MATCH"]}" \
    | sed "s/,/ /g" \
  ); do
    if echo "${name,,}" \
        | grep --quiet "${this_name,,}"; then
      continue
    fi

    has_reverse_name=true
  done
}

function set_vga_type_match_property
{
  if echo "${name,,}" \
      | grep --quiet "vga"; then
    has_vga=true
  fi
}

function verify_groups
{
  local -i greatest_iommu="$( \
    ls /sys/kernel/iommu_groups/ \
      | sort --reverse --version-sort \
      | head --lines 1
  )"

  if ! is_comma_delimited_list_of_positive_numbers \
      "${ARGUMENTS["GROUPS_TO_MATCH"]}" \
    || [[ "$( echo "${ARGUMENTS["GROUPS_TO_MATCH"]}" \
      | sort --reverse --version-sort \
      | --lines 1)" -gt "${greatest_iommu}" ]]; then
    echo -e "Error: Invalid IOMMU group ID(s) specified."

    echo "Please enter a number between '${MIN_IOMMU_VALUE}' and '${greatest_iommu}'."

    exit 1
  fi

  if ! is_comma_delimited_list_of_positive_numbers \
      "${ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]}" \
    || [[ "$( echo "${ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]}" \
      | sort --reverse --version-sort \
      | --lines 1)" -gt "${greatest_iommu}" ]]; then
    echo -e "Error: Invalid IOMMU group ID(s) specified."

    echo "Please enter a number between '${MIN_IOMMU_VALUE}' and '${greatest_iommu}'."

    exit 1
  fi
}

function verify_vga_group_index
{
  vga_group_index="${1}"

  if [[ -z "${ARGUMENTS["VGA_GROUP_INDEX_TO_MATCH"]}" ]]; then
    return 0
  fi

  for this_vga_group_index in $( \
    echo "${ARGUMENTS["VGA_GROUP_INDEX_TO_MATCH"]}" \
      | sed "s/,/ /g"
  ); do
    if [[ "${this_vga_group_index}" -le "${vga_group_index}" ]]; then
      continue
    fi

    is_quiet_enabled && exit 1
    echo -e "Error: Invalid index specified."

    echo "Please enter a value between '${MIN_VGA_INDEX_VALUE}' and" \
      "'${vga_group_index}'."

    exit 1
  done
}

function wrap_text
{
  if [[ -z "${1}" ]]; then
    return 1
  fi

  local column_prefix_text=""
  local -i column_prefix_width="${1}"
  shift
  local -i column_width="${1}"
  shift

  if ! "${USE_WORD_WRAP}" \
    || ! [[ "${column_width}" =~ ^[0-9]+$ ]] \
    || [[ "${column_width}" =~ ^[-][0-9]+$ ]]; then
    echo -e "$@"
    return
  fi

  if [[ "${column_prefix_width}" =~ ^[0-9]+$ ]] \
    || [[ "${column_prefix_width}" =~ ^[-][0-9]+$ ]]; then
    for index in $( seq 0 "${column_prefix_width}" ); do
      column_prefix_text+=" "
    done

    column_width=$(( column_width - ${column_prefix_width} ))
  fi

  if [[ "${column_width}" -lt 0 ]]; then
    column_width=$(( column_width * -1 ))
  fi

  set -o noglob
  IFS=$'\n'

  lines="$( \
    echo "$@" \
      | fold --spaces --width="${column_width}" \
  )"

  lines=(${lines[@]})

  set +o noglob
  unset IFS
  echo -e "${lines[0]}"

  if [[ "${#lines[@]}" -lt 1 ]]; then
    return
  fi

  unset 'lines[0]'

  for line in "${lines[@]}"; do
    line="$( \
      echo "${line}" \
        | sed 's/^[ \t]*//;s/[ \t]*$//'
    )"

    line="${column_prefix_text}${line}"
    echo -e " ${line}"
  done

  unset lines
}

function main
{
  parse_arguments "${@}"
  local -a group_output=()
  parse_groups
  print_output
}

main "$@"