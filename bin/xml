#!/bin/false

set -o xtrace

#
# params
#
  if [[ -z "${1}" ]]; then
    exit 1
  fi

  declare -gr XML_FILE="${1}"

  declare -ag XML_KEYS_A=(
    "devices"
  )

  declare -Ag XML_KEYS_B=(
    [${XML_KEYS_A[0]}]="hardware"
  )

  declare -Ag XML_KEYS_C=(
    [${XML_KEYS_B[${XML_KEYS_A[0]}]}]="@id,driver"
  )

  declare -Ag XML_KEYS_D=(
    [${XML_KEYS_C[${XML_KEYS_B[${XML_KEYS_A[0]}]}]}]="@id"
  )

#
# logic
#
  function get_attribute_at_index
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -n reference="${1}"
    local -ir min_index=0

    if ! is_integer "${2}" \
      || [[ "${2}" -lt -1 ]]; then
      return 1
    fi

    local -i attribute_index="${2}"

    shift
    shift

    if is_empty_string "${@}"; then
      return 1
    fi

    local -a attribute_list=()
    local -i index=1

    while true; do
      attribute="$( \
        echo "${@}" \
          | cut --delimiter ',' --fields "${index}" \
      )"

      if is_empty_string "${attribute}"; then
        break
      fi

      if [[ "${attribute}" =~ ^"@" ]]; then
        attribute_list+=( "${attribute}" )
      fi

      (( index++ ))
    done

    attribute_at_index="${attribute_list["${attribute_index}"]}"

    if is_empty_string "${attribute_at_index}"; then
      return 1
    fi

    reference="${attribute_at_index}"
  }

  function get_bus_id_from_hardware_id
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -n reference="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r hardware_id="${2}"

    local -r bus_id_from_hardware_id="$( \
      lspci -n \
        | grep "${hardware_id}" \
        | head --lines 1 \
        | awk 'END {print $1}' \
    )"

    if is_empty_string "${bus_id_from_hardware_id}"; then
      return 1
    fi

    reference="${bus_id_from_hardware_id}"
    return 0
  }

  function get_key_at_index
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -n reference="${1}"
    local -ir min_index=0
    local -i index="${min_index}"

    if is_empty_string "${2}"; then
      index="${2}"
    fi

    if [[ "${index}" -lt "${min_index}" ]] \
      || ! is_positive_integer "${index}"; then
      return 1
    fi

    shift
    shift

    if is_empty_string "${@}"; then
      return 1
    fi

    local -r get_key="$( \
      echo -e "${@}" \
        | grep --invert-match "^[@]" \
        | tail +${index} \
        | head --lines 1
    )"

    if is_empty_string "${get_key}"; then
      return 1
    fi

    reference="${get_key}"
  }

  function get_driver_from_hardware_id
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -n reference="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r hardware_index="${2}"
    local bus_id=""

    get_bus_id_from_hardware_id \
      "bus_id" \
      "${hardware_index}"

    local driver_from_hardware_id="$( \
      lspci -kns "${bus_id}" \
        | grep driver \
        | awk 'END {print $5}'
    )"

    if is_empty_string "${driver_from_hardware_id}"; then
      return 1
    fi

    reference="${driver_from_hardware_id}"
    return 0
  }

  function get_driver_from_driver_index
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -n reference="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r hardware_index="${2}"

    if ! is_positive_integer "${3}"; then
      return 1
    fi

    local -i driver_id="${3}"
    local -r devices_tag="${XML_KEYS_A[0]}"
    local -r hardware_tag="${XML_KEYS_B[${devices_tag}]}"
    local -r key_c="${XML_KEYS_C[${hardware_tag}]}"
    local key_c_list=()

    get_space_list_from_comma_list "key_c_list" "${key_c}"

    IFS=$'\n'

    key_c_list="$( \
      echo -e "${key_c_list}" \
        | grep -i "^[@]"
    )"

    local hardware_id
    get_attribute_at_index "hardware_id" "${key_c_list[@]}"

    local -r key_d="${XML_KEYS_D[${key_d}]}"
    local key_d_list=()
    get_space_list_from_comma_list "key_d_list" "${key_d}"

    local driver_id
    get_attribute_at_index "driver_id" "${key_d_list[@]}"

    unset IFS

    local -r driver_tag="driver"

    local -r driver_from_driver_index="$(
      xmlstarlet sel --template --value-of \
        "//xml/${devices_tag}/${hardware_tag}[${hardware_id}=\"${hardware_index}\"]/${driver_tag}[${driver_id}=\"${driver_id}\"]" \
        "${XML_FILE}" \
          | head --lines 1
    )"

    if is_empty_string "${driver_from_driver_index}"; then
      return 1
    fi

    reference="${driver_from_driver_index}"
  }

  function get_driver_from_hardware_index
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -n reference="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r hardware_index="${2}"
    local driver_from_hardware_index=""

    get_driver_from_hardware_id \
      "${hardware_index}" \
      "driver_from_hardware_index"

    if ! is_empty_string "${driver_from_hardware_id}" \
      || ! [[ "${driver_from_hardware_id}" =~ "stub" ]] \
      || ! [[ "${driver_from_hardware_id}" =~ "vfio" ]]; then
      local -ir driver_index="${3}"

      get_driver_from_driver_index \
        "driver_from_hardware_index" "${hardware_index}" "${driver_index}"

      if is_empty_string "${driver_from_hardware_index}"; then
        return 1
      fi
    fi

    reference="${driver_from_hardware_index}"
    return 0
  }

  function get_space_list_from_comma_list
  {
    local -n reference="${1}"
    shift

    if is_empty_string "${@}"; then
      return 1
    fi

    local -a newline_list=()
    local index=1

    while true; do
      local value="$( \
        echo "${@}" \
          | cut --delimiter "," --fields "${index}"
      )"

      if is_empty_string "${value}"; then
        break
      fi

      newline_list+=( "${value}" )
      (( index++ ))
    done

    IFS=$'\n'
    newline_list="$( echo ${newline_list[@]} )"
    unset IFS

    if [[ "${#newline_list[@]}" -lt 1 ]]; then
      return 1
    fi

    reference="${newline_list[@]}"
    return 0
  }

  function is_empty_string
  {
    if [[ ! -z "${1}" ]]; then
      return 1
    fi

    return 0
  }

  function is_integer
  {
    if is_empty_string "${1}" \
      || ! [[ "${1}" =~ ^[0-9]+$ ]] \
      && ! [[ "${1}" =~ ^-[0-9]+$ ]]; then
      return 1
    fi

    return 0
  }

  function is_negative_integer
  {
    if is_integer "${1}" \
      || [[ "${1}" -ge 0 ]]; then
      return 1
    fi

    return 0
  }

  function is_positive_integer
  {
    if is_integer "${1}" \
      || [[ "${1}" -lt 0 ]]; then
      return 1
    fi

    return 0
  }