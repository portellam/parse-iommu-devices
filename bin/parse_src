#!/bin/false

#
# Filename:       parse_src
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

#
# TODO:
# - [ ] add validation for all inputs.
# - [x] fix output to show every IOMMU group and it's device info.
# - [x] fix lists?
# - [ ] check if all commands used are installed.
# - [x] ignore groups with vfio.
# - [ ] xml file
#   - hardware ID as primary key.
#   - record one or more driver(s).
#   - if `lspcie` differs and is not binded to vfio, update or append.
#   - append new info.
#   - add functionality to sort by driver name?
#  - [ ] populate hardware_id and driver dictionary with xml output.
#  - [ ] replace args and output dict with standalone params.
#  - [ ] add to xml
#  - [ ] delete from xml
#  - [ ] update xml
#  - [ ] create xml
#  - [ ] get next valid value if current is not available (driver is not installed).
#  - [ ] make a command line operator.
#  - [ ] append usage
#  - use this script inside deploy-VFIO.
# - [ ] create logger.
#
# !!! - [ ] save entire lspcie output?

#
# TESTS:
# - [ ] all operators
#   - fix comma delimited lists for each match operator (works for first value).
#  - [ ] group match
#  - [ ] group reverse match
#  - [ ] less output
#  - [ ] min. output
#  - [ ] name match
#  - [x] name reverse match
#  - [x] type match
#  - [x] type reverse match
#  - [x] make match
#  - [x] make reverse match
#  - [ ] vga group index match
# - [ ] test with vfio setup.
#

#
# params (1/2)
#
  if [[ -z "${1}" ]]; then
    exit 1
  fi

  declare -g SOURCE_PATH="${1}"

#
# sources (1/2)
#
  source \
    "${SOURCE_PATH}datatype_src"

#
# params (2/2)
#
  if ! is_string "${2}"; then
    exit 1
  fi

  if ! is_string "${3}"; then
    exit 1
  fi

  declare -g SCRIPT_NAME="${2}"

  declare -gi COLUMN_SIZE="$( \
    tput \
      cols \
  )"

  declare -g LOG_EXTENSION=".log"

  declare -gA OUTPUTS=(
    ["FOUND_GROUP_ID_LIST"]=""
    ["FOUND_HOST_GROUP_ID_LIST"]=""
    ["FOUND_HOST_AND_PCIE_GROUP_ID_LIST"]=""
    ["FOUND_PCIE_GROUP_ID_LIST"]=""
    ["FOUND_VGA_GROUP_ID_LIST"]=""
    ["SELECTED_DRIVER_LIST"]=""
    ["SELECTED_GROUP_ID_LIST"]=""
    ["SELECTED_HARDWARE_ID_LIST"]=""
    ["UNSELECTED_GROUP_ID_LIST"]=""
    ["FOUND_VFIO_GROUP_ID_LIST"]=""
  )

  declare -gr VFIO_DRIVER_LIST="pci-stub,vfio-pci"
  declare -gr VGA_TYPE_LIST="graphics,vga,video"

#
# sources (2/2)
#
  source \
    "${SOURCE_PATH}file_src"

  source \
    "${SOURCE_PATH}print_src" \
    "${SOURCE_PATH}" \
    "${SCRIPT_NAME}${LOG_EXTENSION}" \
    "${COLUMN_SIZE}"

#
# logic
#
  function parse_src_main
  {
    local -a group_output=()
    local -r message="Parsing hardware devices..."

    print_and_log_output \
      "${message}" \
      "${INPUTS["VERBOSE"]}"

    if [[ "${#ORDERED_INPUT_LIST[@]}" -le 0 ]] \
      && ! match_all_groups; then
      print_and_log_output \
        "${message} Failed." \
        "${INPUTS["VERBOSE"]}"

      return 1
    fi

    if [[ "${#ORDERED_INPUT_LIST[@]}" -le 0 ]] \
      || ! parse_many_group_matches; then
      print_and_log_output \
        "${message} Failed." \
        "${INPUTS["VERBOSE"]}"

      return 1
    fi

    print_and_log_output \
      "${message} Successful.\n" \
      "${INPUTS["VERBOSE"]}"

    sort_output_lists
    print_output_lists
    return 0
  }

  #
  # $1 : the IOMMU group ID as an integer.
  # $2 : comma delimited list of Bus ID as a string.
  #
  function append_many_device_info_to_output_files
  {
    if ! is_positive_integer "${1}" \
      || ! is_string "${2}"; then
      return 1
    fi

    local -i device_index=1
    group_output+=( "IOMMU Group ${1}:" )

    local -a bus_id_list="$( \
      echo -e "${2//,/\\n}" \
    )"

    local some_have_host=false
    local some_have_pcie=false
    local some_have_vfio=false
    local some_have_vga=false

    for bus_id in ${bus_id_list[@]}; do
      append_some_device_info_to_output_lists \
        "${bus_id}"
    done

    OUTPUTS["FOUND_GROUP_ID_LIST"]+="${1},"

    if "${some_have_host}" \
      && ! "${some_have_pcie}"; then
      OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]+="${1},"
    fi

    if ! "${some_have_host}" \
      && "${some_have_pcie}"; then
      OUTPUTS["FOUND_PCIE_GROUP_ID_LIST"]+="${1},"
    fi

    if "${some_have_host}" \
      && "${some_have_pcie}"; then
      OUTPUTS["FOUND_HOST_AND_PCIE_GROUP_ID_LIST"]+="${1},"
    fi

    if "${some_have_vfio}"; then
      OUTPUTS["FOUND_VFIO_GROUP_ID_LIST"]+="${1},"
    fi

    if "${some_have_vga}"; then
      (( vga_group_index++ ))
      OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]+="${1},"
    fi

    return 0
  }

  function append_many_matches_to_output_lists
  {
    for match in "${match_iommu_group_list[@]}"; do
      append_some_matches_to_output_lists \
        "${match}"
    done
  }

  #
  # $1 : the IOMMU group ID as an integer.
  #
  function append_some_matches_to_output_lists
  {
    if ! is_positive_integer "${1}"; then
      return 1
    fi

    OUTPUTS["SELECTED_GROUP_ID_LIST"]+="${1},"
    local bus_id_delim="${IOMMU_GROUP_ID_AND_BUS_ID["${1}"]}"

    append_this_match_to_output_lists \
      "${bus_id_delim}"
  }

  function append_many_unmatches_to_output_list
  {
    for unmatch in "${unmatch_iommu_group_list[@]}"; do
      OUTPUTS["UNSELECTED_GROUP_ID_LIST"]+="${unmatch},"
    done
  }

  #
  # $1 : the Bus ID as a string.
  #
  function append_some_device_info_to_output_lists
  {
    if ! is_string "${1}"; then
      return 1
    fi

    local hardware_id="${BUS_ID_AND_HARDWARE_ID[${1}]}"
    local driver=${HARDWARE_ID_AND_DRIVER["${hardware_id}"]}
    local make=${HARDWARE_ID_AND_MAKE["${hardware_id}"]}
    local name=${HARDWARE_ID_AND_NAME["${hardware_id}"]}
    local type=${HARDWARE_ID_AND_TYPE["${hardware_id}"]}

    verify_this_match
    append_this_device_info_to_output_lists
    return 0
  }

  function append_this_device_info_to_output_lists
  {
    if ! is_verbose; then
      return 0
    fi

    if ! is_string "${driver}"; then
      driver="${NULL_VALUE}"
    fi

    local -r tab_prefix="\t\t"
    local -r prefix="${tab_prefix}              "

    local -r hardware_id_output="$( \
      wrap_text \
        true \
        false \
        true \
        "${prefix}" \
        "${COLUMN_SIZE}" \
        "${tab_prefix}Hardware ID:  ${hardware_id}"
    )"

    local -r name_input="${tab_prefix}Name:         ${name}"

    # FIXME: some names do not appear. Why?
    local +r name_output="$( \
      wrap_text \
        true \
        false \
        true \
        "${prefix}" \
        "${COLUMN_SIZE}" \
        "${name_input}"
    )"

    if ! is_string "${name_output}"; then
      name_output="${name_input}"
    fi

    local -r name_output

    local -r type_output="$( \
      wrap_text \
        true \
        false \
        true \
        "${prefix}" \
        "${COLUMN_SIZE}" \
        "${tab_prefix}Type:         ${type}"
    )"

    local -r make_output="$( \
      wrap_text \
        true \
        false \
        true \
        "${prefix}" \
        "${COLUMN_SIZE}" \
        "${tab_prefix}Vendor:       ${make}"
    )"

    group_output+=(
      "\t${device_index}:"
      "${tab_prefix}Slot ID:      ${bus_id}"
      "${make_output}"
      "${name_output}"
      "${type_output}"
      "${tab_prefix}Driver:       ${driver}"
      "${hardware_id_output}"
      ""
    )

    if [[ "${driver}" == "${NULL_VALUE}" ]]; then
      local +r driver
      local -r driver=""
    fi

    (( device_index++ ))
    return 0
  }

  #
  # $1 : comma delimited list of Bus ID as a string.
  #
  function append_this_match_to_output_lists
  {
    if ! is_string "${1}"; then
      return 1
    fi

    local -a bus_id_list="$( \
      echo -e "${1//,/\\n}" \
    )"

    for bus_id in ${bus_id_list[@]}; do
      local hardware_id="${BUS_ID_AND_HARDWARE_ID[${bus_id}]}"
      local driver=${HARDWARE_ID_AND_DRIVER["${hardware_id}"]}
      local make=${HARDWARE_ID_AND_MAKE["${hardware_id}"]}
      local name=${HARDWARE_ID_AND_NAME["${hardware_id}"]}
      local type=${HARDWARE_ID_AND_TYPE["${hardware_id}"]}

      if is_string "${driver}" \
        && [[ "${driver^^}" != "N/A" ]]; then
        OUTPUTS["SELECTED_DRIVER_LIST"]+="${driver},"
      fi

      if is_string "${hardware_id}" \
        && [[ "${hardware_id^^}" != "N/A" ]]; then
        OUTPUTS["SELECTED_HARDWARE_ID_LIST"]+="${hardware_id},"
      fi
    done
  }


  function create_logfile
  {
    if [[ -e "${LOG_FILE}" ]] \
      && ! rm --force "${LOG_FILE}" &> /dev/null; then
      echo -e "Failed to delete logfile."
    fi

    if ! touch "${LOG_FILE}" &> /dev/null; then
      echo -e "Failed to create logfile."
    fi
  }

  #
  # $1 : the Bus ID as a string.
  #
  function get_device_info
  {
    if ! is_string "${1}"; then
      return 1
    fi

    local hardware_id="${BUS_ID_AND_HARDWARE_ID[${1}]}"
    local driver=${HARDWARE_ID_AND_DRIVER["${hardware_id}"]}
    local make=${HARDWARE_ID_AND_MAKE["${hardware_id}"]}
    local name=${HARDWARE_ID_AND_NAME["${hardware_id}"]}
    local type=${HARDWARE_ID_AND_TYPE["${hardware_id}"]}
    return 0
  }

  #
  # $1 : the Hardware ID as a string.
  #
  function get_driver_list
  {
    if ! is_string "${1}"; then
      return 1
    fi

    local -ar get_driver_list="${HARDWARE_ID_AND_DRIVER["${1}"]//,\\n}"

    for key in "${!get_driver_list[@]}"; do
      driver="${get_driver_list["${key}"]}"

      if [[ "${driver}" != "${NULL_VALUE}" ]]; then
        continue
      fi

      echo "${driver}"
    done
  }

  #
  # $1 : the Hardware ID as a string.
  #
  function modify_xml_drivers
  {
    if ! is_string "${1}"; then
      return 1
    fi

    local -r hardware_id="${1}"

    local -ar modify_xml_drivers_list="$( \
      get_driver_list \
        "${hardware_id}" \
    )"

    if "${INPUTS["WRITE_XML"]}" \
      && ! "${INPUTS["READ_XML"]}" \
      && ! set_xml_driver_list "${hardware_id}" "${modify_xml_drivers_list}"; then
      return 1
    fi

    return 0
  }

  function modify_xml_hardware_ids
  {
    if ( \
        ! is_empty_file "${XML_FILE}" \
        || ! validate_xml \
      ) \
      && ! write_xml_template_to_file; then
      return 1
    fi

    if ! write_hardware_ids_to_xml; then
      return 1
    fi

    local -a hardware_id_list=()

    local -ir total_devices="$( \
      lspcie -n \
        | wc --lines \
    )"

    local -i index=1

    while [[ "${index}" -le "${total_devices}" ]]; do
      hardware_id="$( \
        lspcie -n \
          | sed -n "${index} p" \
          | cut --delimiter ' ' --fields 3
      )"

      hardware_id_list+=( "${hardware_id}" )
      (( index++ ))
    done


    if ! write_hardware_ids_to_xml; then
      return 1
    fi

    return 0
  }

  #
  # $1 : IOMMU group ID as an integer.
  # $2 : the boolean dictionary key as a string.
  # $3 : the Bus ID as a string.
  # $4 : the make as a a string.
  # $5 : the name as a a string.
  # $6 : the type as a a string.
  # $7 : the driver as a a string.
  #
  #
  function parse_many_device_matches
  {
    if ! is_positive_integer "${1}" \
      || ! is_string "${2}" \
      || ! is_string "${3}" \
      || ! is_string "${4}" \
      || ! is_string "${5}" \
      || ! is_string "${6}" \
      || ! is_string "${7}"; then
      return 1
    fi

    local use_referenced_list=true
    local value_to_match=""
    local referenced_list=""
    local valid_value_list=""

    case "${2}" in
      "MATCH_GROUPS" )
        value_to_match="${1}"
        referenced_list="GROUPS_MATCH_LIST"
        ;;

      "MATCH_HOST" | "UNMATCH_HOST" )
        value_to_match="${3}"
        valid_value_list="00:"
        use_referenced_list=false
        ;;

      "MATCH_MAKE" )
        value_to_match="${4}"
        referenced_list="MAKES_MATCH_LIST"
        ;;

      "MATCH_NAME" )
        value_to_match="${5}"
        referenced_list="NAMES_MATCH_LIST"
        ;;

      "MATCH_TYPE" )
        value_to_match="${6}"
        referenced_list="TYPES_MATCH_LIST"
        ;;

      "MATCH_VGA" )
        value_to_match="${VGA_TYPE_LIST}"
        referenced_list="VGA_GROUP_INDEX_MATCH_LIST"
        ;;

      "UNMATCH_GROUPS" )
        value_to_match="${1}"
        referenced_list="GROUPS_UNMATCH_LIST"
        ;;

      "UNMATCH_MAKE" )
        value_to_match="${4}"
        referenced_list="MAKES_UNMATCH_LIST"
        ;;

      "UNMATCH_NAME" )
        value_to_match="${5}"
        referenced_list="NAMES_UNMATCH_LIST"
        ;;

      "UNMATCH_TYPE" )
        value_to_match="${6}"
        referenced_list="TYPES_UNMATCH_LIST"
        ;;
    esac

    if "${use_referenced_list}"; then
      parse_some_device_matches \
        "${1}" \
        "${3}" \
        false \
        "${2}" \
        "${referenced_list}" \
        "${value_to_match}"

    else
      parse_some_device_matches \
        "${1}" \
        "${3}" \
        true \
        "${2}" \
        "${valid_value_list}" \
        "${value_to_match}"
    fi
  }

  #
  # $1 : IOMMU group ID as an integer.
  # $2 : the Bus ID as a string.
  # $3 : true/false is list a value or a reference as a boolean.
  # $4 : the boolean dictionary key as a string.
  # $5 : the comma delimited list as a string.
  # $5 : the list dictionary key as a string.
  # $6 : the value to match as a string.
  #
  function parse_some_device_matches
  {
    if ! is_positive_integer "${1}" \
      || ! is_string "${2}" \
      || ! is_boolean "${3}" \
      || ! is_string "${4}" \
      || ! is_string "${5}"; then
      return 1
    fi

    local this_has_match=false
    local this_has_unmatch=false
    local variable_name=""

    if [[ "${4}" =~ "UNMATCH" ]]; then
      variable_name="this_has_unmatch"
      some_have_match=true

    elif ! [[ "${4}" =~ "UNMATCH" ]] \
      && [[ "${4}" =~ "MATCH" ]]; then
      variable_name="this_has_match"
      some_have_match=false

    else
      return 1
    fi

    local -a bus_id_list="$( \
      echo -e "${2//,/\\n}" \
    )"

    for bus_id in ${bus_id_list[@]}; do
      parse_this_device_match \
        "${3}" \
        "${variable_name}" \
        "${4}" \
        "${5}" \
        "${6}"
    done

    is_matched_keyword \
      true \
      "some_have_vfio" \
      true \
      "${VFIO_DRIVER_LIST}" \
      "${6}"

    return 0
  }

  #
  # $1 : true/false is list a value or a reference as a boolean.
  # $2 : this has match/unmatch as a variable reference.
  # $3 : the boolean dictionary key as a string.
  # $4 : the comma delimited list as a string.
  # $4 : the list dictionary key as a string.
  # $5 : the value to match as a string.
  #
  function parse_this_device_match
  {
    if ! is_boolean "${1}" \
      || ! is_variable "${2}" \
      || ! is_string "${3}" \
      || ! is_string "${4}" \
      || ! is_string "${5}"; then
      return 1
    fi

    local do_match_by_keyword=true

    if [[ "${3}" =~ "MATCH_GROUPS" ]]; then
      do_match_by_keyword=false
    fi

    if "${1}"; then
      is_matched_keyword \
        "${do_match_by_keyword}" \
        "${2}" \
        true \
        "${4}" \
        "${5}"

    else
      is_matched_keyword \
        "${do_match_by_keyword}" \
        "${2}" \
        "INPUTS" \
        "${3}" \
        "${4}" \
        "${5}"
    fi

    if "${this_has_match}"; then
      some_have_match=true
    fi

    if "${this_has_unmatch}"; then
      some_have_match=false
    fi

    return 0
  }

  function parse_many_group_matches
  {
    local -a match_iommu_group_list=()
    local -a unmatch_iommu_group_list=()

    local -ir min_vga_group_index=1
    local -i vga_group_index="${min_vga_group_index}"

    local some_have_match=false
    local some_have_vfio=false

    for iommu_group_id in $( seq 0 "${MAX_IOMMU_GROUP_ID}" ); do
      local bus_id_delim="${IOMMU_GROUP_ID_AND_BUS_ID["${iommu_group_id}"]}"

      parse_some_group_matches \
        "${iommu_group_id}" \
        "${bus_id_delim}"

      if ! "${some_have_match}" \
        || "${some_have_vfio}"; then
        remove_value \
          "match_iommu_group_list" \
          "${iommu_group_id}"

        unmatch_iommu_group_list+=( "${iommu_group_id}" )
      fi

      append_many_device_info_to_output_files \
        "${iommu_group_id}" \
        "${bus_id_delim}"
    done

    append_many_matches_to_output_lists
    append_many_unmatches_to_output_list
    trim_output_lists
    return 0
  }

  #
  # $1 : the IOMMU group ID as an integer.
  # $2 : the Bus ID as a string.
  #
  function parse_some_group_matches
  {
    if ! is_positive_integer "${1}" \
      || ! is_string "${2}"; then
      return 1
    fi

    local -a bus_id_list="$( \
      echo -e "${2//,/\\n}" \
    )"

    for bus_id in ${bus_id_list[@]}; do
      parse_this_group_match \
        "${1}" \
        "${bus_id}"
    done

    return 0
  }

  #
  # $1 : the IOMMU group ID as an integer.
  # $2 : the Bus ID as a string.
  #
  function parse_this_group_match
  {
    if ! is_positive_integer "${1}" \
      || ! is_string "${2}"; then
      return 1
    fi

    local hardware_id="${BUS_ID_AND_HARDWARE_ID[${2}]}"
    local driver=${HARDWARE_ID_AND_DRIVER["${hardware_id}"]}
    local make=${HARDWARE_ID_AND_MAKE["${hardware_id}"]}
    local name=${HARDWARE_ID_AND_NAME["${hardware_id}"]}
    local type=${HARDWARE_ID_AND_TYPE["${hardware_id}"]}

    for input in "${ORDERED_INPUT_LIST[@]}"; do
      parse_many_device_matches \
        "${1}" \
        "${input}" \
        "${2}" \
        "${make}" \
        "${name}" \
        "${type}" \
        "${driver}"

      if ! "${some_have_match}" \
        || "${some_have_vfio}" \
        || has_value \
          "match_iommu_group_list" \
          "${1}"; then
        continue
      fi

      match_iommu_group_list+=( "${1}" )
    done

    return 0
  }

  function print_output_lists
  {
    if ! is_verbose; then
      if ! is_string "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}"; then
        return 0
      fi

      print_and_log_output "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}"
      print_and_log_output "${OUTPUTS["SELECTED_DRIVER_LIST"]}"
      return 0
    fi

    if is_verbose_doubled; then
      for line in "${group_output[@]}"; do
        print_and_log_output "${line}"
      done
    fi

    set_null_value_to_empty_output_lists

    print_and_log_output "Found Groups:\n${OUTPUTS["FOUND_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Found Groups with only Host device(s):\n${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Found Groups with only PCIe device(s):\n${OUTPUTS["FOUND_PCIE_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Found Groups with Host/PCIe device(s):\n${OUTPUTS["FOUND_HOST_AND_PCIE_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Found Groups with VGA device(s):\n${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Found Groups with VFIO device(s):\n${OUTPUTS["FOUND_VFIO_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Unselected Groups:\n${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Selected Groups:\n${OUTPUTS["SELECTED_GROUP_ID_LIST"]}\n"

    #
    # NOTE: Print hardware IDs first, as this value is never null, but drivers
    #       may be. Should a user rely on the output as input, the user may only
    #       have to validate if $2 is null or not. Otherwise, the user would have
    #       to validate by regex, which is not nice.
    #

    print_and_log_output \
      "Selected Hardware IDs:\n${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}\n"

    print_and_log_output "Selected Drivers:\n${OUTPUTS["SELECTED_DRIVER_LIST"]}"
    return 0
  }

  function set_null_value_to_empty_output_lists
  {
    if ! is_string "${OUTPUTS["FOUND_GROUP_ID_LIST"]}"; then
      OUTPUTS["FOUND_GROUP_ID_LIST"]="${NULL_VALUE}"
    fi

    if ! is_string "${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}"; then
      OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="${NULL_VALUE}"
    fi

    if ! is_string "${OUTPUTS["FOUND_HOST_AND_PCIE_GROUP_ID_LIST"]}"; then
      OUTPUTS["FOUND_HOST_AND_PCIE_GROUP_ID_LIST"]="${NULL_VALUE}"
    fi

    if ! is_string "${OUTPUTS["FOUND_PCIE_GROUP_ID_LIST"]}"; then
      OUTPUTS["FOUND_PCIE_GROUP_ID_LIST"]="${NULL_VALUE}"
    fi

    if ! is_string "${OUTPUTS["FOUND_VFIO_GROUP_ID_LIST"]}"; then
      OUTPUTS["FOUND_VFIO_GROUP_ID_LIST"]="${NULL_VALUE}"
    fi

    if ! is_string "${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}"; then
      OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="${NULL_VALUE}"
    fi

    if ! is_string "${OUTPUTS["SELECTED_DRIVER_LIST"]}"; then
      OUTPUTS["SELECTED_DRIVER_LIST"]="${NULL_VALUE}"
    fi

    if ! is_string "${OUTPUTS["SELECTED_GROUP_ID_LIST"]}"; then
      OUTPUTS["SELECTED_GROUP_ID_LIST"]="${NULL_VALUE}"
    fi

    if ! is_string "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}"; then
      OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="${NULL_VALUE}"
    fi

    if ! is_string "${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}"; then
      OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="${NULL_VALUE}"
    fi

    return 0
  }

  function sort_output_lists
  {
    OUTPUTS["FOUND_GROUP_ID_LIST"]="$( \
      sort_comma_delimited_list \
        "${OUTPUTS["FOUND_GROUP_ID_LIST"]}" \
    )"

    OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="$( \
      sort_comma_delimited_list \
        "${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}" \
    )"

    OUTPUTS["FOUND_HOST_AND_PCIE_GROUP_ID_LIST"]="$( \
      sort_comma_delimited_list \
        "${OUTPUTS["FOUND_HOST_AND_PCIE_GROUP_ID_LIST"]}" \
    )"

    OUTPUTS["FOUND_PCIE_GROUP_ID_LIST"]="$( \
      sort_comma_delimited_list \
        "${OUTPUTS["FOUND_PCIE_GROUP_ID_LIST"]}" \
    )"

    OUTPUTS["FOUND_VFIO_GROUP_ID_LIST"]="$( \
      sort_comma_delimited_list \
        "${OUTPUTS["FOUND_VFIO_GROUP_ID_LIST"]}" \
    )"

    OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="$( \
      sort_comma_delimited_list \
        "${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}" \
    )"

    OUTPUTS["SELECTED_DRIVER_LIST"]="$( \
      sort_comma_delimited_list \
        "${OUTPUTS["SELECTED_DRIVER_LIST"]}" \
    )"

    OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="$( \
      sort_comma_delimited_list \
        "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}" \
    )"

    OUTPUTS["SELECTED_GROUP_ID_LIST"]="$( \
      sort_comma_delimited_list \
        "${OUTPUTS["SELECTED_GROUP_ID_LIST"]}" \
    )"

    OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="$( \
      sort_comma_delimited_list \
        "${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}" \
    )"

    return 0
  }

  function trim_output_lists
  {
    OUTPUTS["FOUND_GROUP_ID_LIST"]="$( \
      truncate_index_from_delimited_list \
        -1 \
        "${OUTPUTS["FOUND_GROUP_ID_LIST"]}" \
    )"

    OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="$( \
      truncate_index_from_delimited_list \
        -1 \
        "${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}" \
    )"

    OUTPUTS["FOUND_HOST_AND_PCIE_GROUP_ID_LIST"]="$( \
      truncate_index_from_delimited_list \
        -1 \
        "${OUTPUTS["FOUND_HOST_AND_PCIE_GROUP_ID_LIST"]}" \
    )"

    OUTPUTS["FOUND_PCIE_GROUP_ID_LIST"]="$( \
      truncate_index_from_delimited_list \
        -1 \
        "${OUTPUTS["FOUND_PCIE_GROUP_ID_LIST"]}" \
    )"

    OUTPUTS["FOUND_VFIO_GROUP_ID_LIST"]="$( \
      truncate_index_from_delimited_list \
        -1 \
        "${OUTPUTS["FOUND_VFIO_GROUP_ID_LIST"]}" \
    )"

    OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="$( \
      truncate_index_from_delimited_list \
        -1 \
        "${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}" \
    )"

    OUTPUTS["SELECTED_DRIVER_LIST"]="$( \
      truncate_index_from_delimited_list \
        -1 \
        "${OUTPUTS["SELECTED_DRIVER_LIST"]}" \
    )"

    OUTPUTS["SELECTED_GROUP_ID_LIST"]="$( \
      truncate_index_from_delimited_list \
        -1 \
        "${OUTPUTS["SELECTED_GROUP_ID_LIST"]}" \
    )"

    OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="$( \
      truncate_index_from_delimited_list \
        -1 \
        "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}" \
    )"

    OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="$( \
      truncate_index_from_delimited_list \
        -1 \
        "${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}" \
    )"

    return 0
  }

  # TODO: debug here.
  function verify_this_match
  {
    local this_has_host=false
    local this_has_vfio=false
    local this_has_vga=false

    is_matched_keyword \
      true \
      "this_has_host" \
      true \
      "00:" \
      "${bus_id}"

    is_matched_keyword \
      true \
      "this_has_vfio" \
      true \
      "${VFIO_DRIVER_LIST}" \
      "${driver}"

    is_matched_keyword \
      true \
      "this_has_vga" \
      true \
      "${VGA_TYPE_LIST}" \
      "${type}"

    if "${this_has_host}"; then
      some_have_host=true

    else
      some_have_pcie=true
    fi

    if "${this_has_vfio}"; then
      some_have_vfio=true
    fi

    if "${this_has_vga}"; then
      some_have_vga=true
    fi

    return 0
  }

  function write_hardware_ids_to_xml
  {
    if "${INPUTS["WRITE_XML"]}" \
      && ! "${INPUTS["READ_XML"]}" \
      && ! set_xml_hardware_id_list \
        true \
        ${hardware_id_list[@]}; then
      return 1
    fi

    return 0
  }