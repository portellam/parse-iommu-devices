#!/bin/false

#
# Filename:       parse_src
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

#
# TODO:
# - [ ] add validation for all inputs.
# - [x] fix output to show every IOMMU group and it's device info.
# - [x] fix lists?
# - [ ] check if all commands used are installed.
# - [x] ignore groups with vfio.
# - [ ] xml file
#   - hardware ID as primary key.
#   - record one or more driver(s).
#   - if `lspci` differs and is not binded to vfio, update or append.
#   - append new information.
#   - add functionality to sort by driver name?
#  - [ ] add to xml
#  - [ ] delete from xml
#  - [ ] update xml
#  - [ ] create xml
#  - [ ] get next valid value if current is not available (driver is not installed).
#  - [ ] make a command line operator.
#  - [ ] append usage
#  - use this script inside deploy-VFIO.
# - [ ] create logger.
#

#
# TESTS:
# - [ ] all operators
#   - fix comma delimited lists for each match operator (works for first value).
#  - [ ] group match
#  - [ ] group reverse match
#  - [ ] less output
#  - [ ] min. output
#  - [ ] name match
#  - [x] name reverse match
#  - [x] type match
#  - [x] type reverse match
#  - [x] vendor match
#  - [x] vendor reverse match
#  - [ ] vga group index match
# - [ ] test with vfio setup.
#

#
# params (1/2)
#
  if [[ -z "${1}" ]]; then
    exit 1
  fi
  declare -g SOURCE_PATH="${1}"

#
# sources (1/2)
#
  source \
    "${SOURCE_PATH}datatype_src" \
    "${SOURCE_PATH}"

#
# params (2/2)
#
  shopt -s nullglob   # aid with argument inputs.

  if is_empty_string "${2}"; then
    exit 1
  fi

  if is_empty_string "${3}"; then
    exit 1
  fi

  declare -g SCRIPT_NAME="${2}"
  declare -g SCRIPT_VERSION="${3}"
  declare -g LOG_EXTENSION=".log"
  declare -g XML_EXTENSION=".xml"

  declare -gi COLUMN_SIZE="$( tput cols )"
  declare -gi MIN_VGA_INDEX_VALUE=1
  declare -gi MIN_IOMMU_VALUE=0
  declare -g NULL_VALUE="N/A"

  # TODO: replace dict with params, make it easier to reference in functions.

  declare -gA ARGUMENTS=(
    ["GET_LESS_OUTPUT"]=false
    ["GET_MINIMUM_OUTPUT"]=false
    ["GROUPS_TO_MATCH"]=""
    ["GROUPS_TO_REVERSE_MATCH"]=""
    ["MATCH_GROUPS"]=false
    ["MATCH_HOST"]=false
    ["MATCH_NAME"]=false
    ["MATCH_PCI"]=false
    ["MATCH_VGA_GROUP_INDEX"]=false
    ["MATCH_TYPE"]=false
    ["MATCH_VENDOR"]=false
    ["NAMES_TO_MATCH"]=""
    ["NAMES_TO_REVERSE_MATCH"]=""
    ["REVERSE_MATCH_GROUPS"]=false
    ["REVERSE_MATCH_NAME"]=false
    ["REVERSE_MATCH_TYPE"]=false
    ["REVERSE_MATCH_VENDOR"]=false
    ["TYPES_TO_MATCH"]=""
    ["TYPES_TO_REVERSE_MATCH"]=""
    ["USE_XML"]=true
    ["XML_FILE"]="${SCRIPT_NAME}${XML_EXTENSION}"
    ["VENDORS_TO_MATCH"]=""
    ["VENDORS_TO_REVERSE_MATCH"]=""
    ["VGA_GROUP_INDEX_TO_MATCH"]=""
  )

  declare -gA OUTPUTS=(
    ["FOUND_GROUP_ID_LIST"]=""
    ["FOUND_HOST_GROUP_ID_LIST"]=""
    ["FOUND_PCI_GROUP_ID_LIST"]=""
    ["FOUND_VGA_GROUP_ID_LIST"]=""
    ["SELECTED_DRIVER_LIST"]=""
    ["SELECTED_GROUP_ID_LIST"]=""
    ["SELECTED_HARDWARE_ID_LIST"]=""
    ["UNSELECTED_GROUP_ID_LIST"]=""
    ["VFIO_GROUP_ID_LIST"]=""
  )

#
# sources (2/2)
#
  source \
    "${SOURCE_PATH}print_src" \
    "${SOURCE_PATH}" \
    "${SCRIPT_NAME}${LOG_EXTENSION}" \
    "${COLUMN_SIZE}"

  source \
    "${SOURCE_PATH}xml_src" \
    "${SOURCE_PATH}" \
    "${ARGUMENTS["XML_FILE"]}"

#
# logic
#
  function append_output_to_lists
  {
    if "${has_host}"; then
      OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]+="${group_id},"
    fi

    if "${has_pci}"; then
      OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]+="${group_id},"
    fi

    if "${has_vfio}"; then
      OUTPUTS["VFIO_GROUP_ID_LIST"]+="${group_id},"
    fi

    if "${has_vga}"; then
      OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]+="${group_id},"
      (( vga_group_index++ ))
    fi

    if ! "${is_selected}"; then
      OUTPUTS["UNSELECTED_GROUP_ID_LIST"]+="${group_id},"
      return 0
    fi

    OUTPUTS["SELECTED_DRIVER_LIST"]+="${driver_list}"
    OUTPUTS["SELECTED_GROUP_ID_LIST"]+="${group_id},"
    OUTPUTS["SELECTED_HARDWARE_ID_LIST"]+="${hardware_id_list}"
  }

  function append_output_to_temp_lists
  {
    if ! get_minimum_output; then
      if [[ -z "${driver}" ]]; then
        driver="${NULL_VALUE}"
      fi

      local -r tab_prefix="\t\t"
      local -r prefix="${tab_prefix}              "

      local -r hardware_id_output="$( \
        wrap_text \
          true \
          true \
          "${prefix}" \
          "${COLUMN_SIZE}" \
          "${tab_prefix}Hardware ID:  ${hardware_id}"
      )"

      local -r name_input="${tab_prefix}Name:         ${name}"

      # FIXME: some names do not appear. Why?
      local name_output="$( \
        wrap_text \
          true \
          true \
          "${prefix}" \
          "${COLUMN_SIZE}" \
          "${name_input}"
      )"

      if [[ -z "${name_output}" ]]; then
        name_output="${name_input}"
      fi

      readonly name_output

      local -r type_output="$( \
        wrap_text \
          true \
          true \
          "${prefix}" \
          "${COLUMN_SIZE}" \
          "${tab_prefix}Type:         ${type}"
      )"

      local -r vendor_output="$( \
        wrap_text \
          true \
          true \
          "${prefix}" \
          "${COLUMN_SIZE}" \
          "${tab_prefix}Vendor:       ${vendor}"
      )"

      group_temp_output+=(
        "\t${device_index}:"
        "${tab_prefix}Slot ID:      ${bus_id}"
        "${vendor_output}"
        "${name_output}"
        "${type_output}"
        "${tab_prefix}Driver:       ${driver}"
        "${hardware_id_output}"
        ""
      )
    fi

    if [[ "${driver}" != "${NULL_VALUE}" ]] \
      && ! [[ ",${driver_list,,}," =~ ",${driver,,}," ]]; then
      driver_list+="${driver},"
    fi

    if [[ "${hardware_id}" != "${NULL_VALUE}" ]] \
      && [[ ",${hardware_id_list,,}," != *",${hardware_id},"* ]]; then
      hardware_id_list+="${hardware_id},"
    fi
  }

  function create_logfile
  {
    if [[ -e "${LOG_FILE}" ]] \
      && ! rm --force "${LOG_FILE}" &> /dev/null; then
      echo -e "Failed to delete logfile."
    fi

    if ! touch "${LOG_FILE}" &> /dev/null; then
      echo -e "Failed to create logfile."
    fi
  }

  function convert_found_group_id_newline_celimited_list_to_comma_delimited_list
  {
    if [[ -z "${OUTPUTS["FOUND_GROUP_ID_LIST"]}" ]]; then
      OUTPUTS["FOUND_GROUP_ID_LIST"]="N/A"
      return 0
    fi

    OUTPUTS["FOUND_GROUP_ID_LIST"]="${OUTPUTS["FOUND_GROUP_ID_LIST"]::-1}"

    OUTPUTS["FOUND_GROUP_ID_LIST"]="$( \
      echo "${OUTPUTS["FOUND_GROUP_ID_LIST"]}" \
        | sed --expression $'s/,/\\\n/g' \
        | sort --numeric-sort \
        | tr '\n' ',' \
        | sed 's/.$//' \
        | tr ',' '\n' \
        | sort --human-numeric-sort --unique \
        | xargs \
        | tr ' ' ','
    )"
  }

  function convert_found_host_group_id_newline_celimited_list_to_comma_delimited_list
  {
    if [[ -z "${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}" ]]; then
      OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="N/A"
      return 0
    fi

    OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]::-1}"

    OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]="$( \
      echo "${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}" \
        | sed --expression $'s/,/\\\n/g' \
        | sort --numeric-sort \
        | tr '\n' ',' \
        | sed 's/.$//' \
        | tr ',' '\n' \
        | sort --human-numeric-sort --unique \
        | xargs \
        | tr ' ' ','
    )"
  }

  function convert_found_pci_group_id_newline_celimited_list_to_comma_delimited_list
  {
    if [[ -z "${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]}" ]]; then
      OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]="N/A"
      return 0
    fi

    OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]="${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]::-1}"

    OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]="$( \
      echo "${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]}" \
        | sed --expression $'s/,/\\\n/g' \
        | sort --numeric-sort \
        | tr '\n' ',' \
        | sed 's/.$//' \
        | tr ',' '\n' \
        | sort --human-numeric-sort --unique \
        | xargs \
        | tr ' ' ','
    )"
  }

  function convert_found_vga_group_id_newline_celimited_list_to_comma_delimited_list
  {
    if [[ -z "${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}" ]]; then
      OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="N/A"
      return 0
    fi

    OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]::-1}"

    OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="$( \
      echo "${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}" \
        | sed --expression $'s/,/\\\n/g' \
        | sort --numeric-sort \
        | tr '\n' ',' \
        | sed 's/.$//' \
        | tr ',' '\n' \
        | sort --unique \
        | xargs \
        | tr ' ' ','
    )"
  }

  function convert_selected_driver_newline_celimited_list_to_comma_delimited_list
  {
    if [[ -z "${OUTPUTS["SELECTED_DRIVER_LIST"]}" ]]; then
      OUTPUTS["SELECTED_DRIVER_LIST"]="N/A"
      return 0
    fi

    OUTPUTS["SELECTED_DRIVER_LIST"]="${OUTPUTS["SELECTED_DRIVER_LIST"]::-1}"

    OUTPUTS["SELECTED_DRIVER_LIST"]="$( \
      echo "${OUTPUTS["SELECTED_DRIVER_LIST"]}" \
        | sed --expression $'s/,/\\\n/g' \
        | sort --numeric-sort \
        | tr '\n' ',' \
        | sed 's/.$//' \
        | tr ',' '\n' \
        | sort --unique \
        | xargs \
        | tr ' ' ','
    )"
  }

  function convert_selected_group_id_newline_celimited_list_to_comma_delimited_list
  {
    if [[ -z "${OUTPUTS["SELECTED_GROUP_ID_LIST"]}" ]]; then
      OUTPUTS["SELECTED_GROUP_ID_LIST"]="N/A"
      return 0
    fi

    OUTPUTS["SELECTED_GROUP_ID_LIST"]="${OUTPUTS["SELECTED_GROUP_ID_LIST"]::-1}"

    OUTPUTS["SELECTED_GROUP_ID_LIST"]="$( \
      echo "${OUTPUTS["SELECTED_GROUP_ID_LIST"]}" \
        | sed --expression $'s/,/\\\n/g' \
        | sort --numeric-sort \
        | tr '\n' ',' \
        | sed 's/.$//' \
        | tr ',' '\n' \
        | sort --human-numeric-sort --unique \
        | xargs \
        | tr ' ' ','
    )"
  }

  function convert_selected_hardware_id_newline_celimited_list_to_comma_delimited_list
  {
    if [[ -z "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}" ]]; then
      OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="N/A"
      return 0
    fi

    OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]::-1}"

    OUTPUTS["SELECTED_HARDWARE_ID_LIST"]="$( \
      echo "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}" \
        | sed --expression $'s/,/\\\n/g' \
        | sort --numeric-sort \
        | tr '\n' ',' \
        | sed 's/.$//' \
        | tr ',' '\n' \
        | sort --unique \
        | xargs \
        | tr ' ' ','
    )"
  }

  function convert_unselected_group_id_newline_celimited_list_to_comma_delimited_list
  {
    if [[ -z "${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}" ]]; then
      OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="N/A"
      return 0
    fi

    OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]::-1}"

    OUTPUTS["UNSELECTED_GROUP_ID_LIST"]="$( \
      echo "${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}" \
        | sed --expression $'s/,/\\\n/g' \
        | sort --numeric-sort \
        | tr '\n' ',' \
        | sed 's/.$//' \
        | tr ',' '\n' \
        | sort --human-numeric-sort --unique \
        | xargs \
        | tr ' ' ','
    )"
  }

  function convert_vfio_group_id_newline_celimited_list_to_comma_delimited_list
  {
    if [[ -z "${OUTPUTS["VFIO_GROUP_ID_LIST"]}" ]]; then
      OUTPUTS["VFIO_GROUP_ID_LIST"]="N/A"
      return 0
    fi

    OUTPUTS["VFIO_GROUP_ID_LIST"]="${OUTPUTS["VFIO_GROUP_ID_LIST"]::-1}"

    OUTPUTS["VFIO_GROUP_ID_LIST"]="$( \
      echo "${OUTPUTS["VFIO_GROUP_ID_LIST"]}" \
        | sed --expression $'s/,/\\\n/g' \
        | sort --numeric-sort \
        | tr '\n' ',' \
        | sed 's/.$//' \
        | tr ',' '\n' \
        | sort --human-numeric-sort --unique \
        | xargs \
        | tr ' ' ','
    )"
  }

  function is_output_not_empty
  {
    if [[ "${#group_output[@]}" -lt 1 ]]; then
      return 1
    fi
  }

  function get_less_output
  {
    if ! "${ARGUMENTS["GET_LESS_OUTPUT"]}"; then
      return 1
    fi

    return 0
  }

  function get_minimum_output
  {
    if ! "${ARGUMENTS["GET_MINIMUM_OUTPUT"]}"; then
      return 1
    fi

    return 0
  }

  function parse_arguments
  {
    if [[ "${1}" == "-"* ]] \
      && [[ "${1}" != "--"* ]]; then
      for char in $( \
        echo "${1:1}" \
          | sed -e 's/\(.\)/\1\n/g'
      ); do
        argument="-${char}"

        if [[ -z "${argument}" ]]; then
          break
        fi

        parse_argument "${argument}"
      done

      shift
    fi

    parse_argument "${@}"
  }

  function parse_argument
  {
    while [[ ! -z "${1}" ]]; do
      case "${1,,}" in
        "-g" | "--group" )
          ARGUMENTS["MATCH_GROUPS"]=true
          shift

          if ! is_comma_delimited_list_of_positive_numbers "${1}" \
            || [[ "${1}" -lt "${MIN_IOMMU_VALUE}" ]]; then
            print_invalid_option
          fi

          ARGUMENTS["GROUPS_TO_MATCH"]="${1}"
          ;;

        "-H" | "--host" )
          ARGUMENTS["MATCH_HOST"]=true
          ;;

        "--ignore-group" )
          ARGUMENTS["REVERSE_MATCH_GROUPS"]=""
          shift

          if ! is_comma_delimited_list_of_positive_numbers "${1}" \
            || [[ "${1}" -lt "${MIN_IOMMU_VALUE}" ]]; then
            print_invalid_option
          fi

          ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]="${1}"
          ;;

        "--ignore-name" )
          ARGUMENTS["REVERSE_MATCH_NAME"]=true
          shift

          if [[ -z "${1}" ]]; then
            print_invalid_option
          fi

          ARGUMENTS["NAMES_TO_REVERSE_MATCH"]="${1}"
          ;;

        "--ignore-type" )
          ARGUMENTS["REVERSE_MATCH_TYPE"]=true
          shift

          if [[ -z "${1}" ]]; then
            print_invalid_option
          fi

          ARGUMENTS["TYPES_TO_REVERSE_MATCH"]="${1}"
          ;;

        "--ignore-vendor" )
          ARGUMENTS["REVERSE_MATCH_VENDOR"]=true
          shift

          if [[ -z "${1}" ]]; then
            print_invalid_option
          fi

          ARGUMENTS["VENDORS_TO_REVERSE_MATCH"]="${1}"
          ;;

        "-n" | "--name" )
          ARGUMENTS["MATCH_NAME"]=true
          shift

          if [[ -z "${1}" ]]; then
            print_invalid_option
          fi

          ARGUMENTS["NAMES_TO_MATCH"]="${1}"
          ;;

        "-p" | "--pci" | "--pcie" )
          ARGUMENTS["MATCH_PCI"]=true
          ;;

        "-q" | "--quiet" )
          ARGUMENTS["GET_LESS_OUTPUT"]=true
          ;;

        "-qq" | "--quieter" )
          ARGUMENTS["GET_MINIMUM_OUTPUT"]=true
          ;;

        "-t" | "--type" )
          ARGUMENTS["MATCH_TYPE"]=true
          shift

          if [[ -z "${1}" ]]; then
            print_invalid_option
          fi

          ARGUMENTS["TYPES_TO_MATCH"]="${1}"
          ;;

        "-v" | "--vendor" )
          ARGUMENTS["MATCH_VENDOR"]=true
          shift

          if [[ -z "${1}" ]]; then
            print_invalid_option
          fi

          ARGUMENTS["VENDORS_TO_MATCH"]="${1}"
          ;;

        "--vga-index" )
          ARGUMENTS["MATCH_VGA_GROUP_INDEX"]=true
          shift

          if ! is_comma_delimited_list_of_positive_numbers "${1}" \
            || [[ "${1}" -lt "${MIN_VGA_INDEX_VALUE}" ]]; then
            print_invalid_option
          fi

          ARGUMENTS["VGA_GROUP_INDEX_TO_MATCH"]="${1}"
          ;;

        "" )
          return 0
          ;;

        "-h" | "--help" )
          print_usage
          exit 2
          ;;

        * )
          print_invalid_argument
          ;;

      esac

      shift
    done
  }

  function parse_this_group_devices
  {
    is_selected=false
    bus_id=""
    driver=""
    hardware_id=""
    name=""
    type=""
    vendor=""

    set_device_properties
    set_group_properties
    set_name_match_property
    set_name_reverse_match_property
    set_type_match_property
    set_type_reverse_match_property
    set_vendor_match_property
    set_vendor_reverse_match_property
    set_vfio_match_property
    set_vga_type_match_property

    if "${has_vfio}";then
      return 1
    fi

    append_output_to_temp_lists

    if "${ARGUMENTS["MATCH_HOST"]}" \
        && ! "${has_host}"; then
      return 1
    fi

    if "${ARGUMENTS["MATCH_PCI"]}" \
        && ! "${has_pci}"; then
      return 1
    fi

    if "${ARGUMENTS["MATCH_NAME"]}" \
        && ! "${has_name}"; then
      return 1
    fi

    if "${ARGUMENTS["MATCH_TYPE"]}" \
        && ! "${has_type}"; then
      return 1
    fi

    if "${ARGUMENTS["MATCH_VENDOR"]}" \
        && ! "${has_vendor}"; then
      return 1
    fi

    if "${ARGUMENTS["REVERSE_MATCH_NAME"]}" \
        && "${has_name_reverse_match}"; then
      return 1
    fi

    if "${ARGUMENTS["REVERSE_MATCH_TYPE"]}" \
        && "${has_type_reverse_match}"; then
      return 1
    fi

    if "${ARGUMENTS["REVERSE_MATCH_VENDOR"]}" \
        && "${has_vendor_reverse_match}"; then
      return 1
    fi

    if "${ARGUMENTS["MATCH_VGA_GROUP_INDEX"]}" \
        && ! "${has_vga}"; then
      return 1
    fi

    is_selected=true
  }

  function parse_this_group
  {
    group_id="${group##*/}"
    OUTPUTS["FOUND_GROUP_ID_LIST"]+="${group_id},"

    if ! get_minimum_output; then
      group_output+=( "IOMMU Group ${group_id}:" )
    fi

    device_index=0
    group_id_list=""
    driver_list=""
    hardware_id_list=""
    has_host=false
    has_pci=false
    has_name=false
    has_name_reverse_match=false
    has_type=false
    has_type_reverse_match=false
    has_vendor=false
    has_vendor_reverse_match=false
    has_vfio=false
    has_vga=false
    is_selected=false
    local -a group_temp_output=()

    for device in ${group##}/devices/*; do
      parse_this_group_devices || continue

      if [[ ",${group_id_list,,}," != *",${group_id},"* ]]; then
        group_id_list+="${group_id},"
      fi
    done

    if ! get_minimum_output; then
      if [[ "${#group_temp_output[@]}" -lt 1 ]]; then
        group_output+=(
          "\tNo devices matched or found for group ${group_id}."
          ""
        )
      else
        group_output+=( "${group_temp_output[@]}" )
      fi
    fi
  }

  function parse_many_groups
  {
    local -i vga_group_index=0

    for group in $( \
      find /sys/kernel/iommu_groups/* -maxdepth 0 -type d \
        | sort --version-sort
    ); do
      parse_this_group
      append_output_to_lists
    done

    if ! verify_vga_group_index "${vga_group_index}"; then
      return 1
    fi

    convert_found_group_id_newline_celimited_list_to_comma_delimited_list
    convert_found_host_group_id_newline_celimited_list_to_comma_delimited_list
    convert_found_pci_group_id_newline_celimited_list_to_comma_delimited_list
    convert_found_vga_group_id_newline_celimited_list_to_comma_delimited_list
    convert_selected_driver_newline_celimited_list_to_comma_delimited_list
    convert_selected_group_id_newline_celimited_list_to_comma_delimited_list
    convert_selected_hardware_id_newline_celimited_list_to_comma_delimited_list
    convert_unselected_group_id_newline_celimited_list_to_comma_delimited_list
    convert_vfio_group_id_newline_celimited_list_to_comma_delimited_list
  }

  function print_invalid_argument
  {
    get_minimum_output && exit 1
    print_and_log_output "Error: Invalid argument(s) specified."
    print_usage
    exit 1
  }

  function print_invalid_option
  {
    get_minimum_output && exit 1
    print_and_log_output "Error: Invalid option specified."
    print_usage
    exit 1
  }

  function print_groups_output
  {
    if ! get_less_output; then
      if ! is_output_not_empty; then
        print_and_log_output "Error: No IOMMU groups found."
        return 1
      fi

      for line in "${group_output[@]}"; do
        print_and_log_output "${line}"
      done
    fi

    print_and_log_output "Found Groups:\n${OUTPUTS["FOUND_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Found Groups with Host device(s):\n${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Found Groups with PCI device(s):\n${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Found Groups with VGA device(s):\n${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Unselected Groups:\n${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Unselected Groups binded to VFIO:\n${OUTPUTS["VFIO_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Selected Groups:\n${OUTPUTS["SELECTED_GROUP_ID_LIST"]}\n"

    #
    # NOTE: Print hardware IDs first, as this value is never null, but drivers
    #       may be. Should a user rely on the output as input, the user may only
    #       have to validate if $2 is null or not. Otherwise, the user would have
    #       to validate by regex, which is not nice.
    #

    print_and_log_output \
      "Selected Hardware IDs:\n${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}\n"

    print_and_log_output "Selected Drivers:\n${OUTPUTS["SELECTED_DRIVER_LIST"]}"

    if ! get_minimum_output; then
      return 0
    fi

    print_and_log_output "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}"
    print_and_log_output "${OUTPUTS["SELECTED_DRIVER_LIST"]}"
  }

  function print_usage
  {
    if get_minimum_output; then
      return 0
    fi

    local -i column_prefix_count=28

    wrap_text \
      false \
      false \
      false \
      0 \
      "${COLUMN_SIZE}" \
      "Usage:\t${SCRIPT_NAME} [ARGUMENTS]"

    wrap_text \
      false \
      false \
      false \
      0 \
      "${COLUMN_SIZE}" \
      "Parse, sort, and display hardware devices by IOMMU group(s)."

    wrap_text \
      false \
      false \
      false \
      0 \
      "${COLUMN_SIZE}" \
      "Version ${SCRIPT_VERSION}."

    echo
    echo -en "  -h, --help                "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Print this help and exit."

    echo -en "  -q, --quiet               "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Quiet most output except for IOMMU groups output, and lists of device drivers"\
        "and hardware IDs."

    echo -en "  -qq, --very-quiet         "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Quiet all output except for lists of device drivers and hardware IDs."

    echo -en "  -g, --group=GROUPS        "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group ID(s);"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "GROUPS is a comma delimited list of positive numbers."

    echo -en "  --ignore-group=GROUPS     "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Reverse match IOMMU group ID(s), overrides \"--group\";"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "GROUPS is a comma delimited list of positive numbers."

    echo -en "  -H, --host                "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU groups with at least one (1) or more Host devices."

    echo -en "  -n, --name=NAME           "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) with device name;"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "NAME is a comma delimited list of text."

    echo -en "  --ignore-name=NAME        "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) without device name, overrides \"--name\";"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "NAME is a comma delimited list of text."

    echo -en "  -t, --type=TYPE           "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) with device type;"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "TYPE is a comma delimited list of text."

    echo -en "  --ignore-type=TYPE        "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) without device type, overrides \"--type\";"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "TYPE is a comma delimited list of text."

    echo -en "  -v, --vendor=VENDOR       "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) with device vendor;"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "VENDOR is a comma delimited list of text."

    echo -en "  --ignore-vendor=VENDOR    "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) without device vendor, overrides \"--vendor\";"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "VENDOR is a comma delimited list of text."

    echo -en "  -p, --pci, --pcie         "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU groups with at least one (1) or more PCI/PCIe bus devices."

    echo -en "  --vga-index=INDEX         "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match all IOMMU groups without VGA," \
      "and any with VGA which match the index value(s) (not an IOMMU group ID);"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "INDEX is a comma delimited list of postive non-zero numbers."

    echo -e "Examples:"

    echo -en "  ${SCRIPT_NAME} " # do wrap_text for args here.

    column_prefix_count=$(( "${#SCRIPT_NAME}" + 3 ))

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "--ignore-name ether --pcie -qq --vga-index 2"

    echo -en "$( get_repeated_space 28 )"

    column_prefix_count=28
    text="Quiet output except for drivers and "
    text+="hardware IDs (of IOMMU groups with PCI/e devices), exclude IOMMU "
    text+="groups with VGA device(s) before and after the second matched group, "
    text+="and exclude any wired ethernet devices (Host and PCI/e)."

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "${text}"
  }

  function set_device_properties
  {
    (( device_index++ ))

    bus_id="$( \
      lspci -ns ${device##*/} \
        | awk 'END {print $1}' \
    )"

    hardware_id="$( \
      lspci -ns ${device##*/} \
        | awk 'END {print $3}' \
    )"

    get_driver_from_hardware_index "driver" "${hardware_id}" 0

    name="$( \
      lspci -ms ${device##*/} \
        | cut --delimiter '"' --fields 6 \
    )"

    type="$( \
      lspci -ms ${device##*/} \
        | cut --delimiter '"' --fields 2 \
    )"

    vendor="$( \
      lspci -ms ${device##*/} \
        | cut --delimiter '"' --fields 4 \
    )"
  }

  function set_group_properties
  {
    internal_bus_id="00"
    this_bus_id="${bus_id::2}"

    if [[ "${this_bus_id}" == "${internal_bus_id}" ]]; then
      has_host=true
    else
      has_pci=true
    fi
  }

  function set_name_match_property
  {
    if "${has_name}" \
      || ! "${ARGUMENTS["MATCH_NAME"]}"; then
      return 0
    fi

    for this_name in $( \
      echo "${ARGUMENTS["NAMES_TO_MATCH"]}" \
        | sed "s/,/ /g"
    ); do
      if [[ "${name,,}" =~ "${this_name,,}" ]]; then
        has_name=true
        break
      fi
    done
  }

  function set_name_reverse_match_property
  {
    if "${has_name_reverse_match}" \
      || ! "${ARGUMENTS["REVERSE_MATCH_NAME"]}"; then
      return 0
    fi

    for this_name in $( \
      echo "${ARGUMENTS["NAMES_TO_REVERSE_MATCH"]}" \
        | sed "s/,/ /g" \
    ); do
      if [[ "${name,,}" =~ "${this_name,,}" ]]; then
        has_name_reverse_match=true
        break
      fi
    done
  }

  function set_type_match_property
  {
    if "${has_type}" \
      || ! "${ARGUMENTS["MATCH_TYPE"]}"; then
      return 0
    fi

    for this_type in $( \
      echo "${ARGUMENTS["TYPES_TO_MATCH"]}" \
        | sed "s/,/ /g"
    ); do
      if [[ "${type,,}" =~ "${this_type,,}" ]]; then
        has_type=true
        break
      fi
    done
  }

  function set_type_reverse_match_property
  {
    if "${has_type_reverse_match}" \
      || ! "${ARGUMENTS["REVERSE_MATCH_TYPE"]}"; then
      return 0
    fi

    for this_type in $( \
      echo "${ARGUMENTS["TYPES_TO_REVERSE_MATCH"]}" \
        | sed "s/,/ /g" \
    ); do
      if [[ "${type,,}" =~ "${this_type,,}" ]]; then
        has_type_reverse_match=true
        break
      fi
    done
  }

  function set_vendor_match_property
  {
    if "${has_vendor}" \
      || ! "${ARGUMENTS["MATCH_VENDOR"]}"; then
      return 0
    fi

    for this_vendor in $( \
      echo "${ARGUMENTS["VENDORS_TO_MATCH"]}" \
        | sed "s/,/ /g" \
    ); do
      if [[ "${vendor,,}" =~ "${this_vendor,,}" ]]; then
        has_vendor=true
        break
      fi
    done
  }

  function set_vendor_reverse_match_property
  {
    if "${has_vendor_reverse_match}" \
      || ! "${ARGUMENTS["REVERSE_MATCH_VENDOR"]}"; then
      return 0
    fi

    for this_vendor in $( \
      echo "${ARGUMENTS["VENDORS_TO_REVERSE_MATCH"]}" \
        | sed "s/,/ /g" \
    ); do
      if [[ "${vendor,,}" =~ "${this_vendor,,}" ]]; then
        has_vendor_reverse_match=true
        break
      fi
    done
  }

  function set_vfio_match_property
  {
    if echo "${driver,,}" \
        | grep --quiet "stub" \
      || echo "${driver,,}" \
        | grep --quiet "vfio"; then
      has_vfio=true
    fi
  }

  function set_vga_type_match_property
  {
    if echo "${type,,}" \
        | grep --quiet "vga"; then
      has_vga=true
    fi
  }

  function verify_groups
  {
    local -i greatest_iommu="$( \
      ls /sys/kernel/iommu_groups/ \
        | sort --reverse --version-sort \
        | head --lines 1
    )"

    local warning="Error: Invalid IOMMU group ID(s) specified. Please enter a "
    warning+="number between '${MIN_IOMMU_VALUE}' and '${greatest_iommu}'."

    if ! is_comma_delimited_list_of_positive_numbers \
        "${ARGUMENTS["GROUPS_TO_MATCH"]}" \
      || [[ "$( \
        echo "${ARGUMENTS["GROUPS_TO_MATCH"]}" \
          | sort --reverse --version-sort \
          | head --lines 1 \
        )" -gt "${greatest_iommu}" ]]; then
      print_and_log_output "${warning}"
      return 1
    fi

    if ! is_comma_delimited_list_of_positive_numbers \
        "${ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]}" \
      || [[ "$( \
        echo "${ARGUMENTS["GROUPS_TO_REVERSE_MATCH"]}" \
          | sort --reverse --version-sort \
          | head --lines 1 \
        )" -gt "${greatest_iommu}" ]]; then
      print_and_log_output "${warning}"
      return 1
    fi
  }

  function verify_vga_group_index
  {
    vga_group_index="${1}"

    if [[ -z "${ARGUMENTS["VGA_GROUP_INDEX_TO_MATCH"]}" ]]; then
      return 0
    fi

    for this_vga_group_index in $( \
      echo "${ARGUMENTS["VGA_GROUP_INDEX_TO_MATCH"]}" \
        | sed "s/,/ /g"
    ); do
      if [[ "${this_vga_group_index}" -le "${vga_group_index}" ]]; then
        continue
      fi

      if get_minimum_output; then
        return 1
      fi

      print_and_log_output "Error: Invalid index specified."

      print_and_log_output \
        "Please enter a value between '${MIN_VGA_INDEX_VALUE}' and" \
        "'${vga_group_index}'."

      return 1
    done
  }