#!/bin/false

#
# Filename:       parse_src
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

#
# TODO:
# - [ ] add validation for all inputs.
# - [x] fix output to show every IOMMU group and it's device info.
# - [x] fix lists?
# - [ ] check if all commands used are installed.
# - [x] ignore groups with vfio.
# - [ ] xml file
#   - hardware ID as primary key.
#   - record one or more driver(s).
#   - if `lspci` differs and is not binded to vfio, update or append.
#   - append new information.
#   - add functionality to sort by driver name?
#  - [ ] populate hardware_id and driver dictionary with xml output.
#  - [ ] replace args and output dict with standalone params.
#  - [ ] add to xml
#  - [ ] delete from xml
#  - [ ] update xml
#  - [ ] create xml
#  - [ ] get next valid value if current is not available (driver is not installed).
#  - [ ] make a command line operator.
#  - [ ] append usage
#  - use this script inside deploy-VFIO.
# - [ ] create logger.
#
# !!! - [ ] save entire lspci output?

#
# TESTS:
# - [ ] all operators
#   - fix comma delimited lists for each match operator (works for first value).
#  - [ ] group match
#  - [ ] group reverse match
#  - [ ] less output
#  - [ ] min. output
#  - [ ] name match
#  - [x] name reverse match
#  - [x] type match
#  - [x] type reverse match
#  - [x] vendor match
#  - [x] vendor reverse match
#  - [ ] vga group index match
# - [ ] test with vfio setup.
#

# set -o xtrace

#
# params (1/2)
#
  if [[ -z "${1}" ]]; then
    exit 1
  fi
  declare -g SOURCE_PATH="${1}"

#
# sources (1/2)
#
  source \
    "${SOURCE_PATH}datatype_src" \
    "${SOURCE_PATH}"

  source \
    "${SOURCE_PATH}file_src"

  source \
    "${SOURCE_PATH}input_src" \
    "${SOURCE_PATH}"

  source \
    "${SOURCE_PATH}query_src" \
    "${SOURCE_PATH}"
#
# params (2/2)
#
  if is_empty_string "${2}"; then
    exit 1
  fi

  if is_empty_string "${3}"; then
    exit 1
  fi

  declare -g SCRIPT_NAME="${2}"
  declare -g SCRIPT_VERSION="${3}"
  declare -gi COLUMN_SIZE="$( tput cols )"
  declare -g LOG_EXTENSION=".log"
  declare -g XML_EXTENSION=".xml"

  declare -gA OUTPUTS=(
    ["FOUND_GROUP_ID_LIST"]=""
    ["FOUND_HOST_GROUP_ID_LIST"]=""
    ["FOUND_PCI_GROUP_ID_LIST"]=""
    ["FOUND_VGA_GROUP_ID_LIST"]=""
    ["SELECTED_DRIVER_LIST"]=""
    ["SELECTED_GROUP_ID_LIST"]=""
    ["SELECTED_HARDWARE_ID_LIST"]=""
    ["UNSELECTED_GROUP_ID_LIST"]=""
    ["VFIO_GROUP_ID_LIST"]=""
  )

#
# sources (2/2)
#
  source \
    "${SOURCE_PATH}print_src" \
    "${SOURCE_PATH}" \
    "${SCRIPT_NAME}${LOG_EXTENSION}" \
    "${COLUMN_SIZE}"

#
# logic
#
  function append_output_to_temp_lists
  {
    if ! get_minimum_output; then
      if [[ -z "${driver}" ]]; then
        driver="${NULL_VALUE}"
      fi

      local -r tab_prefix="\t\t"
      local -r prefix="${tab_prefix}              "

      local -r hardware_id_output="$( \
        wrap_text \
          true \
          false \
          true \
          "${prefix}" \
          "${COLUMN_SIZE}" \
          "${tab_prefix}Hardware ID:  ${hardware_id}"
      )"

      local -r name_input="${tab_prefix}Name:         ${name}"

      # FIXME: some names do not appear. Why?
      local name_output="$( \
        wrap_text \
          true \
          false \
          true \
          "${prefix}" \
          "${COLUMN_SIZE}" \
          "${name_input}"
      )"

      if [[ -z "${name_output}" ]]; then
        name_output="${name_input}"
      fi

      readonly name_output

      local -r type_output="$( \
        wrap_text \
          true \
          false \
          true \
          "${prefix}" \
          "${COLUMN_SIZE}" \
          "${tab_prefix}Type:         ${type}"
      )"

      local -r vendor_output="$( \
        wrap_text \
          true \
          false \
          true \
          "${prefix}" \
          "${COLUMN_SIZE}" \
          "${tab_prefix}Vendor:       ${vendor}"
      )"

      group_temp_output+=(
        "\t${device_index}:"
        "${tab_prefix}Slot ID:      ${bus_id}"
        "${vendor_output}"
        "${name_output}"
        "${type_output}"
        "${tab_prefix}Driver:       ${driver}"
        "${hardware_id_output}"
        ""
      )
    fi

    if [[ "${driver}" != "${NULL_VALUE}" ]] \
      && ! [[ ",${driver_list,,}," =~ ",${driver,,}," ]]; then
      driver_list+="${driver},"
    fi

    if [[ "${hardware_id}" != "${NULL_VALUE}" ]] \
      && [[ ",${hardware_id_list,,}," != *",${hardware_id},"* ]]; then
      hardware_id_list+="${hardware_id},"
    fi
  }

  function create_logfile
  {
    if [[ -e "${LOG_FILE}" ]] \
      && ! rm --force "${LOG_FILE}" &> /dev/null; then
      echo -e "Failed to delete logfile."
    fi

    if ! touch "${LOG_FILE}" &> /dev/null; then
      echo -e "Failed to create logfile."
    fi
  }

  function get_bus_id_from_hardware_id
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -n reference="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r hardware_id="${2,,}"

    local -r bus_id_from_hardware_id="$( \
      lspci -n \
        | grep "${hardware_id}" \
        | head --lines 1 \
        | awk 'END {print $1}' \
    )"

    if is_empty_string "${bus_id_from_hardware_id}"; then
      return 1
    fi

    reference="${bus_id_from_hardware_id,,}"
    return 0
  }

  function get_driver_from_hardware_id
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -n reference="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r hardware_index="${2}"
    local bus_id=""

    get_bus_id_from_hardware_id \
      "bus_id" \
      "${hardware_index}"

    local driver_from_hardware_id="$( \
      lspci -kns "${bus_id}" \
        | grep driver \
        | awk 'END {print $5}'
    )"

    if is_empty_string "${driver_from_hardware_id}"; then
      return 1
    fi

    reference="${driver_from_hardware_id,,}"
    return 0
  }

  function get_driver_from_hardware_index
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -n reference="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r hardware_index="${2}"
    local driver_from_hardware_index=""
    get_driver_from_hardware_id "driver_from_hardware_index" "${hardware_index}"

    if is_empty_string "${driver_from_hardware_index}" \
      || [[ "${driver_from_hardware_index}" =~ "stub" ]] \
      || [[ "${driver_from_hardware_index}" =~ "vfio" ]]; then
      if ! "${INPUTS["READ_XML"]}"; then
        return 1
      fi

      local -ir driver_index="${3}"

      if is_positive_integer "${driver_index}"; then
        driver_from_hardware_index="$( \
          get_xml_driver \
            "${hardware_index}" \
            "${driver_index}"
        )"
      else
        driver_from_hardware_index="$( \
          get_first_valid_driver \
            "${hardware_index}" \
        )"
      fi

      if ! is_empty_string "${driver_from_hardware_index}"; then
        return 1
      fi
    fi

    reference="${driver_from_hardware_index,,}"

    if ! modify_xml_drivers "${hardware_index}" "${reference}"; then
      return 1
    fi

    return 0
  }

  function get_first_valid_driver
  {
    for driver in $( get_key_c "${1}" ); do
      if is_driver_installed "${driver}"; then
        echo "${driver}"
        return 0
      fi
    done

    return 1
  }

  function is_driver_installed
  {
    lsmod \
      | grep --quiet --word-regexp "${1}"
  }

  function is_output_not_empty
  {
    if [[ "${#group_output[@]}" -lt 1 ]]; then
      return 1
    fi
  }

  function is_matched
  {
    if ! is_variable "${1}"; then
      return 2
    fi

    local -n reference_is_matched="${1}"

    if ! is_boolean "${reference_is_matched}"; then
      return 2
    fi

    if ! is_variable "${2}"; then
      return 2
    fi

    local do_match=false
    local things_to_match=""

    if is_dict "${2}"; then
      local -n is_matched_dict="${2}"
      shift
    fi

    if ! is_string "${2}"; then
      return 2
    fi

    if is_variable "is_matched_dict"; then
      do_match="${is_matched_dict["${2}"]}"
      things_to_match="${is_matched_dict["${3}"]}"

      if ! is_boolean "${do_match}" \
        || ! is_string "${things_to_match}"; then
        return 2
      fi
    else
      if ! is_boolean "${2}"; then
        return 2
      fi

      do_match="${2}"
      shift

      if ! is_string "${2}"; then
        return 2
      fi

      things_to_match="${2}"
      shift
    fi

    if "${reference_is_matched}" \
      || ! "${do_match}"; then
      return 0
    fi

    local things="${@}"

    for this_thing in $( \
      echo "${things_to_match}" \
        | sed "s/,/ /g"
    ); do
      if echo "${things[@],,}" \
          | grep --quiet "${this_thing,,}"; then
        reference_is_matched=true
        return 0
      fi
    done

    reference_is_matched=false
    return 1
  }

  function modify_xml_drivers
  {
    if "${INPUTS["WRITE_XML"]}" \
      && ! "${INPUTS["READ_XML"]}" \
      && ! set_xml_driver_list "${1}" "${2}"; then
      return 1
    fi

    return 0
  }

  function modify_xml_hardware_ids
  {
    if ( \
        ! is_empty_file "${XML_FILE}" \
        || ! validate_xml \
      ) \
      && ! write_xml_template_to_file; then
      return 1
    fi

    if ! write_hardware_ids_to_xml; then
      return 1
    fi

    local -a hardware_id_list=()

    local -ir total_devices="$( \
      lspci -n \
        | wc --lines \
    )"

    echo "${total_devices}"

    exit 1

    local -i index=1

    while [[ "${index}" -le "${total_devices}" ]]; do
      hardware_id="$( \
        lspci -n \
          | sed -n "${index} p" \
          | cut --delimiter ' ' --fields 3
      )"

      hardware_id_list+=( "${hardware_id}" )
      (( index++ ))
    done

    exit 1

    if ! write_hardware_ids_to_xml; then
      return 1
    fi

    exit 1
    return 0
  }

  function print_groups_output
  {
    if ! get_less_output; then
      if ! is_output_not_empty; then
        print_and_log_output "Error: No IOMMU groups found."
        return 1
      fi

      for line in "${group_output[@]}"; do
        print_and_log_output "${line}"
      done
    fi

    print_and_log_output "Found Groups:\n${OUTPUTS["FOUND_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Found Groups with Host device(s):\n${OUTPUTS["FOUND_HOST_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Found Groups with PCI device(s):\n${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Found Groups with VGA device(s):\n${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Unselected Groups:\n${OUTPUTS["UNSELECTED_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Unselected Groups binded to VFIO:\n${OUTPUTS["VFIO_GROUP_ID_LIST"]}\n"

    print_and_log_output \
      "Selected Groups:\n${OUTPUTS["SELECTED_GROUP_ID_LIST"]}\n"

    #
    # NOTE: Print hardware IDs first, as this value is never null, but drivers
    #       may be. Should a user rely on the output as input, the user may only
    #       have to validate if $2 is null or not. Otherwise, the user would have
    #       to validate by regex, which is not nice.
    #

    print_and_log_output \
      "Selected Hardware IDs:\n${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}\n"

    print_and_log_output "Selected Drivers:\n${OUTPUTS["SELECTED_DRIVER_LIST"]}"

    if ! get_minimum_output; then
      return 0
    fi

    print_and_log_output "${OUTPUTS["SELECTED_HARDWARE_ID_LIST"]}"
    print_and_log_output "${OUTPUTS["SELECTED_DRIVER_LIST"]}"
  }

  function set_host_or_pci_flag
  {
    if ! is_string "${1}"; then
      return 1
    fi

    local -r this_bus_id="${1::2}"
    local -r internal_bus_id="00"

    if [[ "${this_bus_id}" == "${internal_bus_id}" ]]; then
      has_host=true
      has_pci=false
    else
      has_host=false
      has_pci=true
    fi
  }

  function set_sources
  {
    source \
    "${SOURCE_PATH}xml_src" \
    "${SOURCE_PATH}" \
    "${INPUTS["XML_FILE"]}" \
    "${INPUTS["READ_XML"]}"
  }

  function verify_all_devices_matches
  {
    for iommu_group_id in "${IOMMU_GROUP_ID_LIST[@]}"; do
      verify_many_devices_matches "${iommu_group_id}"
    done

    OUTPUTS["FOUND_GROUP_ID_LIST"]="${OUTPUTS["FOUND_GROUP_ID_LIST"]::-1}"
    OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]="${OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]::-1}"
    OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]="${OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]::-1}"
  }

  function verify_this_devices_matches
  {
    if ! is_string "${1}"; then
      return 1
    fi

    local -r bus_id="${1}"
    local -r hardware_id="${BUS_ID_AND_HARDWARE_ID["${bus_id}"]}"
    local -r driver="${HARDWARE_ID_AND_DRIVER["${hardware_id}"]}"
    local -r name="${HARDWARE_ID_AND_NAME["${hardware_id}"]}"
    local -r type="${HARDWARE_ID_AND_TYPE["${hardware_id}"]}"
    local -r vendor="${HARDWARE_ID_AND_VENDOR["${hardware_id}"]}"

    set_host_or_pci_flag "${bus_id}"

    is_matched \
      "has_name" \
      "INPUTS" \
      "MATCH_NAME" \
      "MATCH_NAME_LIST" \
      "${name}"

    is_matched \
      "has_name_reverse_match" \
      "INPUTS" \
      "REVERSE_MATCH_NAME" \
      "NAMES_TO_REVERSE_MATCH" \
      "${name}"

    is_matched \
      "has_type" \
      "INPUTS" \
      "MATCH_TYPE" \
      "TYPES_TO_MATCH" \
      "${type}"

    is_matched \
      "has_type_reverse_match" \
      "INPUTS" \
      "REVERSE_MATCH_TYPE" \
      "TYPES_TO_REVERSE_MATCH" \
      "${type}"

    is_matched \
      "has_vendor" \
      "INPUTS" \
      "MATCH_VENDOR" \
      "VENDORS_TO_MATCH" \
      "${vendor}"

    is_matched \
      "has_vendor_reverse_match" \
      "INPUTS" \
      "REVERSE_MATCH_VENDOR" \
      "VENDORS_TO_REVERSE_MATCH" \
      "${vendor}"

    local -ar vfio_driver_list=(
      "pci-stub"
      "vfio-pci"
    )

    is_matched \
      "has_vfio" \
      true \
      "${vfio_driver_list[@]}" \
      "${driver}"

    local -ar vga_type_list=(
      "graphics"
      "vga"
      "video"
    )

    is_matched \
      "has_vga" \
      true \
      "${vga_type_list[@]}" \
      "${type}"

    if "${has_host}" \
      && "${INPUTS["MATCH_HOST"]}"; then
      return 1
    fi

    if "${has_pci}" \
      && "${INPUTS["MATCH_PCI"]}"; then
      return 1
    fi

    if "${has_host}" \
      || "${has_pci}" \
      || "${has_name}" \
      || "${has_name_reverse_match}" \
      || "${has_type}" \
      || "${has_type_reverse_match}" \
      || "${has_vendor}" \
      || "${has_vendor_reverse_match}" \
      || "${has_vfio}" \
      || "${has_vga}"; then
      return 1
    fi

    return 0
  }

  function verify_many_devices_matches
  {
    if ! is_positive_integer "${1}"; then
      return 1
    fi

    has_host=false
    has_pci=false
    has_name=false
    has_name_reverse_match=false
    has_type=false
    has_type_reverse_match=false
    has_vendor=false
    has_vendor_reverse_match=false
    has_vfio=false
    has_vga=false
    is_selected=false

    local bus_id_list="${IOMMU_GROUP_ID_AND_BUS_ID["${1}"]}"

    bus_id_list="$( \
      echo \
        -e \
        "${bus_id_list//,\\n}" \
      | sort \
        --version-sort
      )"

    for bus_id in "${bus_id_list[@]}"; do
      if ! verify_this_devices_matches "${bus_id}"; then
        break
      fi

      is_selected=true
    done

    if "${has_host}"; then
      OUTPUTS["FOUND_GROUP_ID_LIST"]+="${1},"
    fi

    if "${has_pci}"; then
      OUTPUTS["FOUND_PCI_GROUP_ID_LIST"]+="${1},"
    fi

    if "${has_vga}"; then
      (( vga_group_index++ ))
      OUTPUTS["FOUND_VGA_GROUP_ID_LIST"]+="${1},"
    fi

    if "${has_vfio}"; then
      OUTPUTS["FOUND_VFIO_GROUP_ID_LIST"]+="${1},"
    fi

    if "${is_selected}"; then
      OUTPUTS["SELECTED_DRIVER_LIST"]+="${1},"
      OUTPUTS["SELECTED_GROUP_ID_LIST"]+="${1},"
      OUTPUTS["SELECTED_HARDWARE_ID_LIST"]+="${1},"
    else
      OUTPUTS["UNSELECTED_GROUP_ID_LIST"]+="${1},"
    fi
  }

  function write_hardware_ids_to_xml
  {
    if "${INPUTS["WRITE_XML"]}" \
      && ! "${INPUTS["READ_XML"]}" \
      && ! set_xml_hardware_id_list \
        true \
        ${hardware_id_list[@]}; then
      return 1
    fi

    return 0
  }