#!/bin/false

#
# Filename:       input_src
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

source "${SOURCE_PATH}debug_src"

#
# params (1/2)
#
  declare -g SOURCE_PATH="${1}"

#
# sources (1/2)
#
  source \
    "${SOURCE_PATH}datatype_src"

  source \
    "${SOURCE_PATH}file_src"

#
# params (2/2)
#
  shopt -s nullglob   # aid with argument inputs.

  if ! is_string "${2}"; then
    exit 1
  fi

  if ! is_string "${3}"; then
    exit 1
  fi

  declare -g SCRIPT_NAME="${2}"
  declare -g SCRIPT_VERSION="${3}"
  declare -gi COLUMN_SIZE="$( tput cols )"
  declare -gi MIN_VGA_INDEX_VALUE=1
  declare -gi MIN_IOMMU_VALUE=0
  declare -g LOG_EXTENSION=".log"
  declare -g XML_EXTENSION=".xml"
  declare -g ETC_PATH="/usr/local/etc/"

  declare -gir MAX_IOMMU_GROUP_ID="$( \
  ls \
    /sys/kernel/iommu_groups/ \
  | sort \
    --reverse \
    --version-sort \
  | head \
    --lines \
      1 \
)"

  declare -gA INPUTS=(
    ["GROUPS_MATCH_LIST"]=""
    ["GROUPS_UNMATCH_LIST"]=""
    ["MATCH_GROUPS"]=false
    ["MATCH_HOST"]=false
    ["MATCH_NAME"]=false
    ["MATCH_PCIE"]=false
    ["MATCH_VGA"]=false
    ["MATCH_TYPE"]=false
    ["MATCH_MAKE"]=false
    ["NAMES_MATCH_LIST"]=""
    ["NAMES_UNMATCH_LIST"]=""
    ["UNMATCH_GROUPS"]=false
    ["UNMATCH_NAME"]=false
    ["UNMATCH_TYPE"]=false
    ["UNMATCH_MAKE"]=false
    ["TYPES_MATCH_LIST"]=""
    ["TYPES_UNMATCH_LIST"]=""
    ["READ_XML"]=false
    ["VERBOSE"]=false
    ["MORE_VERBOSE"]=false
    ["WRITE_XML"]=false
    ["XML_FILE"]="${ETC_PATH}${SCRIPT_NAME}${XML_EXTENSION}"
    ["MAKES_MATCH_LIST"]=""
    ["MAKES_UNMATCH_LIST"]=""
    ["VGA_GROUP_INDEX_MATCH_LIST"]=""
  )

  declare -g ARGUMENT_MATCH_GROUPS="-g"

  declare -ga ORDERED_INPUT_LIST

#
# sources (2/2)
#
  source \
    "${SOURCE_PATH}print_src" \
    "${SOURCE_PATH}" \
    "${SCRIPT_NAME}${LOG_EXTENSION}" \
    "${COLUMN_SIZE}"

#
# logic
#
  function get_comma_list_of_iommu_group_ids
  {
    seq "${MIN_IOMMU_VALUE}" "${MAX_IOMMU_GROUP_ID}" \
      | tr '\n' ',' \
      | sed 's:,*$::'

    echo
  }

  function get_match_list_by_match_input
  {
    if ! is_variable "${1}"; then
      return 1
    fi

    local -n reference_get_match_list_by_match_input="${1}"

    case "${1}" in
      "MATCH_GROUPS" )
        reference_get_match_list_by_match_input="MATCH_GROUP_LIST"
        ;;

      "MATCH_MAKE" )
        reference_get_match_list_by_match_input="MATCH_MAKE_LIST"
        ;;

      "MATCH_NAME" )
        reference_get_match_list_by_match_input="MATCH_NAME_LIST"
        ;;

      "MATCH_TYPE" )
        reference_get_match_list_by_match_input="MATCH_TYPE_LIST"
        ;;

      "MATCH_VGA" )
        reference_get_match_list_by_match_input="MATCH_GROUP_LIST"
        ;;

      "UNMATCH_GROUPS" )
        reference_get_match_list_by_match_input="UNMATCH_GROUP_LIST"
        ;;

      "UNMATCH_MAKE" )
        reference_get_match_list_by_match_input="UNMATCH_MAKE_LIST"
        ;;

      "UNMATCH_NAME" )
        reference_get_match_list_by_match_input="UNMATCH_NAME_LIST"
        ;;

      "UNMATCH_TYPE" )
        reference_get_match_list_by_match_input="UNMATCH_TYPE_LIST"
        ;;
    esac

    return 0
  }

  function is_argument_or_empty_string
  {
    if ! is_string "${1}"; then
      return 0
    fi

    if [[ "${1}" == "---"* ]]; then
      return 1
    fi

    if [[ "${1}" == "-"* ]] \
      || [[ "${1}" == "--"* ]]; then
      return 0
    fi

    return 1
  }

  #
  # $1 : the boolean as a reference.
  # $2 : the do match boolean to match dictionary key as a string.
  # $3 : the list dictionary key as a string.
  # $2 : the do match flag as a boolean.
  # $4 : the comma delimited list of valid matches as a string.
  # $@ : the values to match as a list.
  #
  function is_matched_keyword
  {
    if ! is_variable "${1}"; then
      return 2
    fi

    local -n reference_is_matched="${1}"

    if ! is_boolean "${reference_is_matched}"; then
      return 2
    fi

    local do_match=false
    local things_to_match=""
    local has_dict=false

    if ! is_string "${2}"; then
      return 2
    fi

    if is_dict "${2}"; then
      has_dict=true
      local -n is_matched_dict="${2}"
      shift
    fi

    if "${has_dict}"; then
      do_match="${is_matched_dict["${2}"]}"
      shift

      if ! is_string "${2}"; then
        return 2
      fi

      things_to_match="${is_matched_dict["${2}"]}"

      if ! is_boolean "${do_match}" \
        || ! is_string "${things_to_match}"; then
        return 2
      fi

    else
      if ! is_boolean "${2}"; then
        return 2
      fi

      do_match="${2}"
      shift

      if ! is_string "${2}"; then
        return 2
      fi

      things_to_match="${2}"
    fi

    shift
    shift
    local things="$@"

    for this_thing in $( \
      echo "${things_to_match}" \
        | sed "s/,/ /g"
    ); do

      if [[ "${things,,}" =~ "${this_thing,,}" ]]; then
        reference_is_matched=true
        return 0
      fi
    done

    reference_is_matched=false
    return 1
  }

  function is_matched_word
  {
    if ! is_variable "${1}"; then
      return 2
    fi

    local -n reference_is_matched="${1}"

    if ! is_boolean "${reference_is_matched}"; then
      return 2
    fi

    local do_match=false
    local things_to_match=""
    local has_dict=false

    if ! is_string "${2}"; then
      return 2
    fi

    if is_dict "${2}"; then
      has_dict=true
      local -n is_matched_dict="${2}"
      shift
    fi

    if "${has_dict}"; then
      do_match="${is_matched_dict["${2}"]}"
      things_to_match="${is_matched_dict["${3}"]}"

      if ! is_boolean "${do_match}" \
        || ! is_string "${things_to_match}"; then
        return 2
      fi

    else
      if ! is_boolean "${2}"; then
        return 2
      fi

      do_match="${2}"

      if ! is_string "${3}"; then
        return 2
      fi

      things_to_match="${3}"
      shift
    fi

    if "${reference_is_matched}" \
      || ! "${do_match}"; then
      return 0
    fi

    shift
    shift
    shift
    local things="$@"

    for this_thing in $( \
      echo "${things_to_match}" \
        | sed "s/,/ /g"
    ); do
      if [[ "${things,,}" == "${this_thing,,}" ]]; then
        reference_is_matched=true
        return 0
      fi
    done

    reference_is_matched=false
    return 1
  }

  function is_verbose
  {
    if ! "${INPUTS["VERBOSE"]}"; then
      return 1
    fi

    return 0
  }

  function is_verbose_doubled
  {
    if ! "${INPUTS["MORE_VERBOSE"]}"; then
      return 1
    fi

    return 0
  }

  function match_all_groups
  {
    parse_this_argument \
      "${ARGUMENT_MATCH_GROUPS}" \
        "$( get_comma_list_of_iommu_group_ids )"
  }

  function parse_many_arguments
  {
    # echo "'${@}'"

    # use a list here

    # while true; do
    #   if ! parse_this_argument "${@}"; then
    #     return 1
    #   fi

    #   shift

    #   # for char in $( \
    #   #   echo "${1:1}" \
    #   #     | sed -e 's/\(.\)/\1\n/g'
    #   # ); do
    #   #   argument="-${char}"

    #   #   if ! is_string "${argument}"; then
    #   #     break
    #   #   fi

    #   #   echo "'${argument}' '${@}'"

    #   #   if ! parse_this_argument "${argument}" "${@}"; then
    #   #     return 1
    #   #   fi

    #   #   shift
    #   # done
    # done

    if ! parse_this_argument "${@}"; then
      return 1
    fi

    return 0
  }

  function parse_this_argument
  {
    while true; do
      local -a this_input_list=()

      case "${1}" in
        "-g" | "--group" | "--groups" | "${ARGUMENT_MATCH_GROUPS}" )
          this_input_list=( "MATCH_GROUPS" )
          shift

          if [[ "${1}" == "all" ]]; then
            INPUTS["GROUPS_MATCH_LIST"]="$( get_comma_list_of_iommu_group_ids )"
          else
            if ! is_comma_delimited_list_of_positive_numbers "${1}" \
              || [[ "${1}" -lt "${MIN_IOMMU_VALUE}" ]]; then
              print_invalid_option "${1}"
            fi

            INPUTS["GROUPS_MATCH_LIST"]="${1}"
          fi
          ;;

        "-H" | "--host" | "--hosts" )
          this_input_list=( "MATCH_HOST" )
          ;;

        "--ignore-group" | "--ignore-groups" )
          this_input_list=( "UNMATCH_GROUPS" )
          shift

          if [[ "${1}" == "all" ]]; then
            INPUTS["GROUPS_UNMATCH_LIST"]="$( get_comma_list_of_iommu_group_ids )"
          else
            if ! is_comma_delimited_list_of_positive_numbers "${1}" \
              || [[ "${1}" -lt "${MIN_IOMMU_VALUE}" ]]; then
              print_invalid_option "${1}"
            fi

            INPUTS["GROUPS_UNMATCH_LIST"]="${1}"
          fi
          ;;

        "--ignore-name" | "--ignore-names" )
          this_input_list=( "UNMATCH_NAME" )
          shift

          if ! is_string "${1}"; then
            print_invalid_option "${1}"
          fi

          INPUTS["NAMES_UNMATCH_LIST"]="${1}"
          ;;

        "--ignore-type" | "--ignore-types" )
          this_input_list=( "UNMATCH_TYPE" )
          shift

          if ! is_string "${1}"; then
            print_invalid_option "${1}"
          fi

          INPUTS["TYPES_UNMATCH_LIST"]="${1}"
          ;;

        "--ignore-vendor" | "--ignore-vendors" )
          this_input_list=( "UNMATCH_MAKE" )
          shift

          if ! is_string "${1}"; then
            print_invalid_option "${1}"
          fi

          INPUTS["MAKES_UNMATCH_LIST"]="${1}"
          ;;

        "-n" | "--name" | "--names" )
          this_input_list=( "MATCH_NAME" )
          shift

          if ! is_string "${1}"; then
            print_invalid_option "${1}"
          fi

          INPUTS["NAMES_MATCH_LIST"]="${1}"
          ;;

        "-p" | "--pci" | "--pcie" )
          this_input_list=( "MATCH_PCIE" )
          ;;

        "-t" | "--type" | "--types" )
          this_input_list=( "MATCH_TYPE" )
          shift

          if ! is_string "${1}"; then
            print_invalid_option "${1}"
          fi

          INPUTS["TYPES_MATCH_LIST"]="${1}"
          ;;

        "-V" | "--vendor" | "--vendors" )
          this_input_list=( "MATCH_MAKE" )
          shift

          if ! is_string "${1}"; then
            print_invalid_option "${1}"
          fi

          INPUTS["MAKES_MATCH_LIST"]="${1}"
          ;;

        "-v" | "--verbose" )
          INPUTS["VERBOSE"]=true
          INPUTS["MORE_VERBOSE"]=false
          ;;

        "-vv" )
          INPUTS["VERBOSE"]=true
          INPUTS["MORE_VERBOSE"]=true
          ;;

        "--vga-index" | "--vga-indexes" )
          this_input_list=( "MATCH_VGA" )
          shift

          if ! is_comma_delimited_list_of_positive_numbers "${1}" \
            || [[ "${1}" -lt "${MIN_VGA_INDEX_VALUE}" ]]; then
            print_invalid_option "${1}"
          fi

          INPUTS["VGA_GROUP_INDEX_MATCH_LIST"]="${1}"
          ;;

        "--x" | "--xml" )
          shift

          case "${1,,}" in
            "import" )
            this_input_list=( "READ_XML" )
            ;;

            "export" )
            this_input_list=( "WRITE_XML" )
            ;;

            * )
            print_invalid_option "${1}"
            ;;
          esac

          shift

          if is_string "${1}"; then
            INPUTS["XML_FILE"]="${1}"
          fi

          set_sources
          ;;

        "" )
          return 0
          ;;

        "-h" | "--help" )
          INPUTS["VERBOSE"]=true
          print_usage
          exit 2
          ;;

        * )
          print_invalid_argument "${1}"
          return 1
          ;;
      esac

      for this_input in "${this_input_list[@]}"; do
        INPUTS["${this_input}"]=true
        ORDERED_INPUT_LIST+=( "${this_input}" )
      done

      shift
    done

    return 0
  }

  function print_invalid_argument
  {
    if ! is_verbose; then
      return 1
    fi

    local message="Error: Invalid argument(s) specified."

    if is_string "${@}"; then
      message="${message::-1}: '${@}'"
    fi

    print_and_log_output "${message}\n"
    print_usage
    return 0
  }

  function print_invalid_option
  {
    if ! is_verbose; then
      exit 1
    fi

    local message="Error: Invalid option specified."

    if is_string "${1}"; then
      message="${message::-1}: '${1}'"
    fi

    print_and_log_output "${message}\n"
    print_usage
    exit 1
  }

  function print_usage
  {
    if ! is_verbose; then
      return 0
    fi

    local -i column_prefix_count=28

    echo -e "Usage:\t${SCRIPT_NAME} [ARGUMENTS]"

    wrap_text \
      false \
      false \
      false \
      0 \
      "${COLUMN_SIZE}" \
      "Parse, sort, and display hardware IDs and device drivers by IOMMU group(s)."

    wrap_text \
      false \
      false \
      false \
      0 \
      "${COLUMN_SIZE}" \
      "Version ${SCRIPT_VERSION}."

    echo
    echo -en "  -h, --help                "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Print this help and exit."

    echo -en "  -v, --verbose             "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Show more output including query output and IOMMU groups."

    echo -en "  -vv                       "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Show all output."

    echo -en "  -g, --group=GROUPS        "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group ID(s);"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "GROUPS is a comma delimited list of positive numbers."

    echo -en "  --ignore-group=GROUPS     "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Reverse match IOMMU group ID(s), overrides \"--group\";"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "GROUPS is a comma delimited list of positive numbers."

    echo -en "  -H, --host                "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU groups with at least one (1) or more Host devices."

    echo -en "  -n, --name=NAME           "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) with device name;"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "NAME is a comma delimited list of text."

    echo -en "  --ignore-name=NAME        "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) without device name, overrides \"--name\";"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "NAME is a comma delimited list of text."

    echo -en "  -t, --type=TYPE           "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) with device type;"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "TYPE is a comma delimited list of text."

    echo -en "  --ignore-type=TYPE        "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) without device type, overrides \"--type\";"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "TYPE is a comma delimited list of text."

    echo -en "  -V, --vendor=VENDOR       "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) with device vendor;"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "VENDOR is a comma delimited list of text."

    echo -en "  --ignore-vendor=VENDOR    "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) without device vendor, overrides \"--vendor\";"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "VENDOR is a comma delimited list of text."

    echo -en "  -p, --pci, --pcie         "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU groups with at least one (1) or more PCI/PCIe bus devices."

    echo -en "  --vga-index=INDEX         "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match all IOMMU groups without VGA," \
      "and any with VGA which match the index value(s) (not an IOMMU group ID);"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "INDEX is a comma delimited list of postive non-zero numbers."

    echo -en "  -x, --xml, --xml=FILE     "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Query an XML file for device drivers should none be found or any devices" \
      "are binded to VFIO;"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "FILE is the XML file name as text. Leave FILE empty to use default file"\
      "name (\"${INPUTS["XML_FILE"]}\")."

    echo -e "Examples:"

    echo -en "  ${SCRIPT_NAME} " # do wrap_text for args here.

    column_prefix_count=$(( "${#SCRIPT_NAME}" + 3 ))

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "--ignore-name ether --pcie --vga-index 2"

    echo -en "$( get_repeated_space 28 )"

    column_prefix_count=28
    text="Standard output of comma-delimited lists hardware IDs and drivers "
    text+="(of IOMMU groups with PCI/e devices), exclude IOMMU groups with VGA "
    text+="device(s) before and after the second matched group, and exclude any "
    text+="wired ethernet devices (Host and PCI/e)."

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "${text}"
  }

  function verify_iommu_groups
  {
    local warning="Error: Invalid IOMMU group ID(s) specified. Please enter a "
    warning+="number between '${MIN_IOMMU_VALUE}' and '${MAX_IOMMU_GROUP_ID}'."

    if ! is_comma_delimited_list_of_positive_numbers \
        "${INPUTS["GROUPS_MATCH_LIST"]}" \
      || [[ "$( \
        echo "${INPUTS["GROUPS_MATCH_LIST"]}" \
          | sort --reverse --version-sort \
          | head --lines 1 \
        )" -gt "${MAX_IOMMU_GROUP_ID}" ]]; then
      print_and_log_output "${warning}"
      return 1
    fi

    if ! is_comma_delimited_list_of_positive_numbers \
        "${INPUTS["GROUPS_UNMATCH_LIST"]}" \
      || [[ "$( \
        echo "${INPUTS["GROUPS_UNMATCH_LIST"]}" \
          | sort --reverse --version-sort \
          | head --lines 1 \
        )" -gt "${MAX_IOMMU_GROUP_ID}" ]]; then
      print_and_log_output "${warning}"
      return 1
    fi
  }

  function verify_vga_group_index
  {
    if ! is_positive_integer "${1}" \
      || [[ "${MIN_VGA_INDEX_VALUE}" -lt "${1}" ]]; then
      return 1
    fi

    vga_group_index="${1}"

    if ! is_string "${INPUTS["VGA_GROUP_INDEX_MATCH_LIST"]}"; then
      return 0
    fi

    for this_vga_group_index in $( \
      echo "${INPUTS["VGA_GROUP_INDEX_MATCH_LIST"]}" \
        | sed "s/,/ /g"
    ); do
      if [[ "${this_vga_group_index}" -le "${vga_group_index}" ]]; then
        continue
      fi

      if ! is_verbose; then
        return 1
      fi

      print_and_log_output "Error: Invalid index specified."

      print_and_log_output \
        "Please enter a value between '${MIN_VGA_INDEX_VALUE}' and" \
        "'${vga_group_index}'."

      return 1
    done
  }