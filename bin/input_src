#!/bin/false

#
# Filename:       input_src
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

#
# params (1/2)
#
  declare -g SOURCE_PATH="${1}"

#
# sources (1/2)
#
  source \
    "${SOURCE_PATH}datatype_src"

  source \
    "${SOURCE_PATH}file_src"

#
# params (2/2)
#
  shopt -s nullglob   # aid with argument inputs.

  if ! is_string "${2}"; then
    exit 1
  fi

  if ! is_string "${3}"; then
    exit 1
  fi

  declare -g SCRIPT_NAME="${2}"
  declare -g SCRIPT_VERSION="${3}"
  declare -gi COLUMN_SIZE="$( tput cols )"
  declare -gi MIN_VGA_INDEX_VALUE=1
  declare -gi MIN_IOMMU_VALUE=0
  declare -g LOG_EXTENSION=".log"
  declare -g XML_EXTENSION=".xml"
  declare -g ETC_PATH="/usr/local/etc/"

  declare -gA INPUTS=(
    ["GROUPS_MATCH_LIST"]=""
    ["GROUPS_UNMATCH_LIST"]=""
    ["MATCH_GROUPS"]=false
    ["MATCH_HOST"]=false
    ["MATCH_NAME"]=false
    ["MATCH_PCI"]=false
    ["MATCH_VGA_GROUP_INDEX"]=false
    ["MATCH_TYPE"]=false
    ["MATCH_VENDOR"]=false
    ["NAMES_MATCH_LIST"]=""
    ["NAMES_UNMATCH_LIST"]=""
    ["UNMATCH_GROUPS"]=false
    ["UNMATCH_NAME"]=false
    ["UNMATCH_TYPE"]=false
    ["UNMATCH_VENDOR"]=false
    ["TYPES_MATCH_LIST"]=""
    ["TYPES_UNMATCH_LIST"]=""
    ["READ_XML"]=false
    ["VERBOSE"]=false
    ["DOUBLE_VERBOSE"]=false
    ["WRITE_XML"]=false
    ["XML_FILE"]="${ETC_PATH}${SCRIPT_NAME}${XML_EXTENSION}"
    ["VENDORS_MATCH_LIST"]=""
    ["VENDORS_UNMATCH_LIST"]=""
    ["VGA_GROUP_INDEX_MATCH_LIST"]=""
  )

#
# sources (2/2)
#
  source \
    "${SOURCE_PATH}print_src" \
    "${SOURCE_PATH}" \
    "${SCRIPT_NAME}${LOG_EXTENSION}" \
    "${COLUMN_SIZE}"

#
# logic
#
  function is_argument_or_empty_string
  {
    if ! is_string "${1}"; then
      return 0
    fi

    if [[ "${1}" == "---"* ]]; then
      return 1
    fi

    if [[ "${1}" == "-"* ]] \
      || [[ "${1}" == "--"* ]]; then
      return 0
    fi

    return 1
  }

  function is_verbose
  {
    if ! "${INPUTS["VERBOSE"]}"; then
      return 1
    fi

    return 0
  }

  function is_verbose_doubled
  {
    if ! "${INPUTS["DOUBLE_VERBOSE"]}"; then
      return 1
    fi

    return 0
  }

  function parse_many_arguments
  {
    # echo "'${@}'"

    # use a list here

    # while true; do
    #   if ! parse_this_argument "${@}"; then
    #     return 1
    #   fi

    #   shift

    #   # for char in $( \
    #   #   echo "${1:1}" \
    #   #     | sed -e 's/\(.\)/\1\n/g'
    #   # ); do
    #   #   argument="-${char}"

    #   #   if ! is_string "${argument}"; then
    #   #     break
    #   #   fi

    #   #   echo "'${argument}' '${@}'"

    #   #   if ! parse_this_argument "${argument}" "${@}"; then
    #   #     return 1
    #   #   fi

    #   #   shift
    #   # done
    # done

    if ! parse_this_argument "${@}"; then
      return 1
    fi

    return 0
  }

  function parse_this_argument
  {
    while $( is_argument_or_empty_string "${1}" ); do
      case "${1}" in
        "-g" | "--group" )
          INPUTS["MATCH_GROUPS"]=true
          shift

          if ! is_comma_delimited_list_of_positive_numbers "${1}" \
            || [[ "${1}" -lt "${MIN_IOMMU_VALUE}" ]]; then
            print_invalid_option
          fi

          INPUTS["GROUPS_MATCH_LIST"]="${1}"
          ;;

        "-H" | "--host" )
          INPUTS["MATCH_HOST"]=true
          ;;

        "--ignore-group" )
          INPUTS["UNMATCH_GROUPS"]=""
          shift

          if ! is_comma_delimited_list_of_positive_numbers "${1}" \
            || [[ "${1}" -lt "${MIN_IOMMU_VALUE}" ]]; then
            print_invalid_option
          fi

          INPUTS["GROUPS_UNMATCH_LIST"]="${1}"
          ;;

        "--ignore-name" )
          INPUTS["UNMATCH_NAME"]=true
          shift

          if ! is_string "${1}"; then
            print_invalid_option
          fi

          INPUTS["NAMES_UNMATCH_LIST"]="${1}"
          ;;

        "--ignore-type" )
          INPUTS["UNMATCH_TYPE"]=true
          shift

          if ! is_string "${1}"; then
            print_invalid_option
          fi

          INPUTS["TYPES_UNMATCH_LIST"]="${1}"
          ;;

        "--ignore-vendor" )
          INPUTS["UNMATCH_VENDOR"]=true
          shift

          if ! is_string "${1}"; then
            print_invalid_option
          fi

          INPUTS["VENDORS_UNMATCH_LIST"]="${1}"
          ;;

        "-n" | "--name" )
          INPUTS["MATCH_NAME"]=true
          shift

          if ! is_string "${1}"; then
            print_invalid_option
          fi

          INPUTS["NAMES_MATCH_LIST"]="${1}"
          ;;

        "-p" | "--pci" | "--pcie" )
          INPUTS["MATCH_PCI"]=true
          ;;

        "-t" | "--type" )
          INPUTS["MATCH_TYPE"]=true
          shift

          if ! is_string "${1}"; then
            print_invalid_option "${1}"
          fi

          INPUTS["TYPES_MATCH_LIST"]="${1}"
          ;;

        "-V" | "--vendor" )
          INPUTS["MATCH_VENDOR"]=true
          shift

          if ! is_string "${1}"; then
            print_invalid_option
          fi

          INPUTS["VENDORS_MATCH_LIST"]="${1}"
          ;;

        "-v" | "--verbose" )
          INPUTS["VERBOSE"]=true
          INPUTS["DOUBLE_VERBOSE"]=false
          ;;

        "-vv" )
          INPUTS["VERBOSE"]=true
          INPUTS["DOUBLE_VERBOSE"]=true
          ;;

        "--vga-index" )
          INPUTS["MATCH_VGA_GROUP_INDEX"]=true
          shift

          if ! is_comma_delimited_list_of_positive_numbers "${1}" \
            || [[ "${1}" -lt "${MIN_VGA_INDEX_VALUE}" ]]; then
            print_invalid_option
          fi

          INPUTS["VGA_GROUP_INDEX_MATCH_LIST"]="${1}"
          ;;

        "--x" | "--xml" )
          shift

          case "${1,,}" in
            "import" )
            INPUTS["READ_XML"]=true
            ;;

            "export" )
            INPUTS["WRITE_XML"]=true
            ;;

            * )
            print_invalid_option
            ;;
          esac

          shift

          if is_string "${1}"; then
            INPUTS["XML_FILE"]="${1}"
          fi

          set_sources
          ;;

        "" )
          return 0
          ;;

        "-h" | "--help" )
          INPUTS["VERBOSE"]=true
          print_usage
          exit 2
          ;;

        * )
          print_invalid_argument
          ;;
      esac

      shift
    done

    return 0
  }

  function print_invalid_argument
  {
    if ! is_verbose; then
      exit 1
    fi

    print_and_log_output "Error: Invalid argument(s) specified."
    print_usage
    exit 1
  }

  function print_invalid_option
  {
    if ! is_verbose; then
      exit 1
    fi

    print_and_log_output "Error: Invalid option specified '${1}'."
    print_usage
    exit 1
  }

  function print_usage
  {
    if ! is_verbose; then
      return 0
    fi

    local -i column_prefix_count=28

    echo -e "Usage:\t${SCRIPT_NAME} [ARGUMENTS]"

    wrap_text \
      false \
      false \
      false \
      0 \
      "${COLUMN_SIZE}" \
      "Parse, sort, and display hardware devices by IOMMU group(s)."

    wrap_text \
      false \
      false \
      false \
      0 \
      "${COLUMN_SIZE}" \
      "Version ${SCRIPT_VERSION}."

    echo
    echo -en "  -h, --help                "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Print this help and exit."

    echo -en "  -v, --verbose             "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Show more output including query telemetry and IOMMU groups"\
        "(all selected, any with VGA, all unselected, and unselected with VFIO)."

    echo -en "  -vv                       "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Show all output."

    # echo -en "  -q, --quiet               "

    # wrap_text \
    #   false \
    #   false \
    #   true \
    #   "${column_prefix_count}" \
    #   "${COLUMN_SIZE}" \
    #   "Quiet most output except for IOMMU groups output, and lists of device drivers"\
    #     "and hardware IDs."

    # echo -en "  -qq, --very-quiet         "

    # wrap_text \
    #   false \
    #   false \
    #   true \
    #   "${column_prefix_count}" \
    #   "${COLUMN_SIZE}" \
    #   "Quiet all output except for lists of device drivers and hardware IDs."

    echo -en "  -g, --group=GROUPS        "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group ID(s);"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "GROUPS is a comma delimited list of positive numbers."

    echo -en "  --ignore-group=GROUPS     "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Reverse match IOMMU group ID(s), overrides \"--group\";"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "GROUPS is a comma delimited list of positive numbers."

    echo -en "  -H, --host                "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU groups with at least one (1) or more Host devices."

    echo -en "  -n, --name=NAME           "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) with device name;"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "NAME is a comma delimited list of text."

    echo -en "  --ignore-name=NAME        "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) without device name, overrides \"--name\";"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "NAME is a comma delimited list of text."

    echo -en "  -t, --type=TYPE           "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) with device type;"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "TYPE is a comma delimited list of text."

    echo -en "  --ignore-type=TYPE        "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) without device type, overrides \"--type\";"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "TYPE is a comma delimited list of text."

    echo -en "  -V, --vendor=VENDOR       "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) with device vendor;"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "VENDOR is a comma delimited list of text."

    echo -en "  --ignore-vendor=VENDOR    "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU group(s) without device vendor, overrides \"--vendor\";"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "VENDOR is a comma delimited list of text."

    echo -en "  -p, --pci, --pcie         "

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match IOMMU groups with at least one (1) or more PCI/PCIe bus devices."

    echo -en "  --vga-index=INDEX         "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Match all IOMMU groups without VGA," \
      "and any with VGA which match the index value(s) (not an IOMMU group ID);"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "INDEX is a comma delimited list of postive non-zero numbers."

    echo -en "  -x, --xml, --xml=FILE     "

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "Query an XML file for device drivers should none be found or any devices" \
      "are binded to VFIO;"

    echo -en "$( get_repeated_space 28 )"

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "FILE is the XML file name as text. Leave FILE empty to use default file"\
      "name (\"${INPUTS["XML_FILE"]}\")."

    echo -e "Examples:"

    echo -en "  ${SCRIPT_NAME} " # do wrap_text for args here.

    column_prefix_count=$(( "${#SCRIPT_NAME}" + 3 ))

    wrap_text \
      false \
      false \
      true \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "--ignore-name ether --pcie --vga-index 2"

    echo -en "$( get_repeated_space 28 )"

    column_prefix_count=28
    text="Standard output of comma-delimited lists hardware IDs and drivers "
    text+="(of IOMMU groups with PCI/e devices), exclude IOMMU groups with VGA "
    text+="device(s) before and after the second matched group, and exclude any "
    text+="wired ethernet devices (Host and PCI/e)."

    wrap_text \
      false \
      false \
      false \
      "${column_prefix_count}" \
      "${COLUMN_SIZE}" \
      "${text}"
  }

  function verify_iommu_groups
  {
    local warning="Error: Invalid IOMMU group ID(s) specified. Please enter a "
    warning+="number between '${MIN_IOMMU_VALUE}' and '${MAX_IOMMU_GROUP_ID}'."

    if ! is_comma_delimited_list_of_positive_numbers \
        "${INPUTS["GROUPS_MATCH_LIST"]}" \
      || [[ "$( \
        echo "${INPUTS["GROUPS_MATCH_LIST"]}" \
          | sort --reverse --version-sort \
          | head --lines 1 \
        )" -gt "${MAX_IOMMU_GROUP_ID}" ]]; then
      print_and_log_output "${warning}"
      return 1
    fi

    if ! is_comma_delimited_list_of_positive_numbers \
        "${INPUTS["GROUPS_UNMATCH_LIST"]}" \
      || [[ "$( \
        echo "${INPUTS["GROUPS_UNMATCH_LIST"]}" \
          | sort --reverse --version-sort \
          | head --lines 1 \
        )" -gt "${MAX_IOMMU_GROUP_ID}" ]]; then
      print_and_log_output "${warning}"
      return 1
    fi
  }

  function verify_vga_group_index
  {
    if ! is_positive_integer "${1}" \
      || [[ "${MIN_VGA_INDEX_VALUE}" -lt "${1}" ]]; then
      return 1
    fi

    vga_group_index="${1}"

    if ! is_string "${INPUTS["VGA_GROUP_INDEX_MATCH_LIST"]}"; then
      return 0
    fi

    for this_vga_group_index in $( \
      echo "${INPUTS["VGA_GROUP_INDEX_MATCH_LIST"]}" \
        | sed "s/,/ /g"
    ); do
      if [[ "${this_vga_group_index}" -le "${vga_group_index}" ]]; then
        continue
      fi

      if ! is_verbose; then
        return 1
      fi

      print_and_log_output "Error: Invalid index specified."

      print_and_log_output \
        "Please enter a value between '${MIN_VGA_INDEX_VALUE}' and" \
        "'${vga_group_index}'."

      return 1
    done
  }