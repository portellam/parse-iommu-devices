#!/bin/false

#
# Filename:       xml_src
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

#
# params (1/2)
#
  if [[ -z "${1}" ]]; then
    exit 1
  fi

  declare -g SOURCE_PATH="${1}"

#
# sources (1/2)
#
  source \
    "${SOURCE_PATH}datatype_src" \
    "${SOURCE_PATH}"

#
# params (2/2)
#
  if is_empty_string "${2}"; then
    exit 1
  fi

  if ! is_boolean "${3}"; then
    exit 1
  fi

  declare -g XML_FILE="${2}"
  declare -g DO_READ_XML_FILE="${3}"
  declare -g ROOT_KEY="xml"
  declare -g KEY_A="devices"
  declare -g KEY_B="hardware"
  declare -g KEY_C="driver"
  declare -g ATTRIBUTE="@id"

  declare -ag XML_KEYS_A=(
    "devices"
  )

  declare -Ag XML_KEYS_B=(
    [${XML_KEYS_A[0]}]="hardware"
  )

  declare -Ag XML_KEYS_C=(
    [${XML_KEYS_B[${XML_KEYS_A[0]}]}]="driver"
  )

#
# logic
#
  function get_bus_id_from_hardware_id
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -n reference="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r hardware_id="${2,,}"

    local -r bus_id_from_hardware_id="$( \
      lspci -n \
        | grep "${hardware_id}" \
        | head --lines 1 \
        | awk 'END {print $1}' \
    )"

    if is_empty_string "${bus_id_from_hardware_id}"; then
      return 1
    fi

    reference="${bus_id_from_hardware_id,,}"
    return 0
  }

  function get_KEY_At_index
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -n reference="${1}"
    local -ir min_index=0
    local -i index="${min_index}"

    if is_empty_string "${2}"; then
      index="${2}"
    fi

    if [[ "${index}" -lt "${min_index}" ]] \
      || ! is_positive_integer "${index}"; then
      return 1
    fi

    shift
    shift

    if is_empty_string "${@}"; then
      return 1
    fi

    local -r get_key="$( \
      echo -e "${@}" \
        | grep --invert-match "^[@]" \
        | tail +${index} \
        | head --lines 1
    )"

    if is_empty_string "${get_key}"; then
      return 1
    fi

    reference="${get_key}"
  }

  function get_driver_from_hardware_id
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -n reference="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r hardware_index="${2}"
    local bus_id=""

    get_bus_id_from_hardware_id \
      "bus_id" \
      "${hardware_index}"

    local driver_from_hardware_id="$( \
      lspci -kns "${bus_id}" \
        | grep driver \
        | awk 'END {print $5}'
    )"

    if is_empty_string "${driver_from_hardware_id}"; then
      return 1
    fi

    reference="${driver_from_hardware_id,,}"
    return 0
  }

  function get_driver_from_driver_index
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -n reference="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r hardware_index="${2}"

    if ! is_positive_integer "${3}"; then
      return 1
    fi

    local -i driver_id="${3}"
    local -r KEY_A="${XML_KEYS_A[0]}"
    local -r KEY_B="${XML_KEYS_B["${KEY_A}"]}"
    local -r KEY_C="${XML_KEYS_C["${KEY_B}"]}"

    local xml_path="//${ROOT_KEY}/${ROOT_KEY}/${KEY_A}/${KEY_B}[${XML_ID_TAG}=\"${hardware_index}\"]"
    xml_path+="/${KEY_C}[${XML_ID_TAG}=\"${driver_id}\"]"

    local -r driver_from_driver_index="$(
      xmlstarlet sel --template --value-of "${xml_path}" "${XML_FILE}" \
        | head --lines 1
    )"

    if is_empty_string "${driver_from_driver_index}"; then
      return 1
    fi

    reference="${driver_from_driver_index,,}"
  }

  function get_driver_from_hardware_index
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -n reference="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r hardware_index="${2}"
    local driver_from_hardware_index=""
    get_driver_from_hardware_id "driver_from_hardware_index" "${hardware_index}"

    if is_empty_string "${driver_from_hardware_index}" \
      || [[ "${driver_from_hardware_index}" =~ "stub" ]] \
      || [[ "${driver_from_hardware_index}" =~ "vfio" ]]; then
      if ! "${DO_READ_XML_FILE}"; then
        return 1
      fi

      local -ir driver_index="${3}"

      get_driver_from_driver_index \
        "driver_from_hardware_index" "${hardware_index}" "${driver_index}"

      if is_empty_string "${driver_from_hardware_index}"; then
        return 1
      fi
    fi

    reference="${driver_from_hardware_index,,}"
    return 0
  }

  function get_driver_comma_list_from_xml
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -r hardware_id="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -n driver_comma_list_from_xml="${2}"
    local driver_comma_list=""
    local -i driver_index=0

    while true; do
      get_driver_from_driver_index \
        "driver_from_hardware_index" "${hardware_id}" "${driver_index}"

      if is_empty_string "${driver_from_hardware_index}"; then
        break
      fi

      driver_comma_list+="${driver_from_hardware_index},"
      (( driver_index++ ))
    done

    if is_empty_string "${driver_comma_list}"; then
      return 1
    fi

    driver_comma_list_from_xml="${driver_comma_list::-1}"
    return 0
  }

  function get_hardware_id_newline_list_from_xml
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -r attribute_value_b="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r value_c="${2}"

    xmlstarlet \
      select \
      --template \
      --copy-of "//${ROOT_KEY}/${XML_KEYS_A[0]}/${XML_KEYS_B["${XML_KEYS_A[0]}"]}" \
      --value-of "${XML_ID_TAG}" \
      -nl \
      "${XML_FILE}" \
      | grep "${XML_KEYS_B["${XML_KEYS_A[0]}"]}" \
      | grep "${XML_ID_TAG}" \
      | cut \
        --delimiter "\"" \
        --fields 2
  }

  function append_key_b
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -r attribute_value_b="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r value_c="${2}"

    xmlstarlet edit \
      --subnode "/${KEY_A}" \
        --type --nl "/${KEY_B}" \
          --value "" \
          --insert "/${ROOT_KEY}/${KEY_A}/${KEY_B}[last()]" \
        --type --nl "${KEY_C}" \
          --value "${attribute_value_b}" \
          --append "/${ROOT_KEY}/${KEY_A}/${KEY_B}[last()]" \
            --insert "${ATTRIBUTE}" \
            --value "${value_c}" \
      "${XML_FILE}"
  }

  function delete_key_b
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -r attribute_value_b="${1}"

    xmlstarlet edit \
      --delete "/${ROOT_KEY}/${KEY_A}/${KEY_B}[${ATTRIBUTE}='${attribute_value_b}']" \
      "${XML_FILE}"
  }

  function get_key_b_list
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -r attribute_value_b="${1}"

    xmlstarlet select \
      --template \
        --match "//${KEY_B}" \
          --value-of "${ATTRIBUTE}" --nl \
      "${XML_FILE}"
  }

  function get_key_c
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -r attribute_value_b="${1}"

    xmlstarlet select \
      --template \
        --match "//${KEY_B} [${ATTRIBUTE}=\"${attribute_value_b}\"]" \
        --match "//${KEY_C}" \
          --value-of "." --nl \
      "${XML_FILE}"
  }

  function insert_key_c
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -r attribute_value_b="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r value_c="${2}"

    xmlstarlet edit \
      --update "/${ROOT_KEY}/${KEY_A}/${KEY_B}[${ATTRIBUTE}='${attribute_value_b}']" \
        --insert @version \
          --value "${value_c}" --nl \
      "${XML_FILE}"
  }

  function update_key_c
  {
    if is_empty_string "${1}"; then
      return 1
    fi

    local -r attribute_value_b="${1}"

    if is_empty_string "${2}"; then
      return 1
    fi

    local -r value_c="${2}"

    xmlstarlet edit \
      --update "/${ROOT_KEY}/${KEY_A}/${KEY_B}[${ATTRIBUTE}='${attribute_value_b}']/${KEY_C}" \
          --value "${value_c}" --nl \
      "${XML_FILE}"
  }